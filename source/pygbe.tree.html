<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pygbe.tree package &mdash; PyGBe 0.2 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="PyGBe 0.2 documentation" href="../index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pygbe-tree-package">
<h1>pygbe.tree package<a class="headerlink" href="#pygbe-tree-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pygbe.tree.FMMutils">
<span id="pygbe-tree-fmmutils-module"></span><h2>pygbe.tree.FMMutils module<a class="headerlink" href="#module-pygbe.tree.FMMutils" title="Permalink to this headline">¶</a></h2>
<p>It contains the functions to build the tree and compute all the interactions.</p>
<dl class="class">
<dt id="pygbe.tree.FMMutils.Cell">
<em class="property">class </em><code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">Cell</code><span class="sig-paren">(</span><em>NCRIT</em>, <em>Nm</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#Cell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.Cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Cell class. It contains the information about the cells in the tree.</p>
<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.nsource">
<code class="descname">nsource</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.nsource" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int, number of source particles.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.ntarget">
<code class="descname">ntarget</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.ntarget" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int, number of target particles.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.nchild">
<code class="descname">nchild</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.nchild" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int, number of child boxes in binary, 8bit value, if certain</em> &#8211; child exists, that bit will be 1.</p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.source">
<code class="descname">source</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.source" title="Permalink to this definition">¶</a></dt>
<dd><p><em>array, pointer to source particles.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.target">
<code class="descname">target</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.target" title="Permalink to this definition">¶</a></dt>
<dd><p><em>array, pointer to target particles.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.xc">
<code class="descname">xc</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.xc" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float, x position of the center of cell.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.yc">
<code class="descname">yc</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.yc" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float, y position of the center of cell.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.zc">
<code class="descname">zc</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.zc" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float, z position of the center of cell.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.r">
<code class="descname">r</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.r" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float, cell radius, i.e half length.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.parent">
<code class="descname">parent</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.parent" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int, pointer to parent cell.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.child">
<code class="descname">child</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.child" title="Permalink to this definition">¶</a></dt>
<dd><p><em>array, pointer to child cell.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.M">
<code class="descname">M</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.M" title="Permalink to this definition">¶</a></dt>
<dd><p><em>array, array with multipoles.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.Md">
<code class="descname">Md</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.Md" title="Permalink to this definition">¶</a></dt>
<dd><p><em>array, array with multipoles for grad(G).n.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.P2P_list">
<code class="descname">P2P_list</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.P2P_list" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list, pointer to cells that interact with P2P.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.M2P_list">
<code class="descname">M2P_list</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.M2P_list" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list, pointer to cells that interact with M2P.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.M2P_size">
<code class="descname">M2P_size</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.M2P_size" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list, size of the M2P interaction list.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.list_ready">
<code class="descname">list_ready</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.list_ready" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int, flag to know if P2P list is already generated.</em></p>
</dd></dl>

<dl class="attribute">
<dt id="pygbe.tree.FMMutils.Cell.twig_array">
<code class="descname">twig_array</code><a class="headerlink" href="#pygbe.tree.FMMutils.Cell.twig_array" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list, position in the twig array.</em></p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.M2PKt_gpu">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">M2PKt_gpu</code><span class="sig-paren">(</span><em>surfSrc</em>, <em>surfTar</em>, <em>Ktx_gpu</em>, <em>Kty_gpu</em>, <em>Ktz_gpu</em>, <em>surf</em>, <em>ind0</em>, <em>param</em>, <em>LorY</em>, <em>timing</em>, <em>kernel</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#M2PKt_gpu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.M2PKt_gpu" title="Permalink to this definition">¶</a></dt>
<dd><p>It computes the far field contribution of the adjoint double potential
using the sorted data, on the GPU.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>surfSrc</strong> (<em>class, source surface, the one that contains the gauss points.</em>) &#8211; </li>
<li><strong>surfTar</strong> (<em>class, target surface, the one that contains the collocation</em>) &#8211; points.</li>
<li><strong>Ktx_gpu</strong> (<em>array, x component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>Kty_gpu</strong> (<em>array, y component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>Ktz_gpu</strong> (<em>array, z component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>surf</strong> (<em>int, position of the source surface in the surface array.</em>) &#8211; </li>
<li><strong>ind0</strong> (<em>list, pointers to the location of the mulipole of order i,j,k</em>) &#8211; in the multipole array.</li>
<li><strong>param</strong> (<em>class, parameters related to the surface.</em>) &#8211; </li>
<li><strong>LorY</strong> (<em>int, Laplace (1) or Yukawa (2).</em>) &#8211; </li>
<li><strong>timing</strong> (<em>class, it contains timing information for different parts of</em>) &#8211; the code.</li>
<li><strong>kernel</strong> (<em>pycuda source module.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>Ktx_gpu</strong> (<em>array, x component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>Kty_gpu</strong> (<em>array, y component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>Ktz_gpu</strong> (<em>array, z component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.M2PKt_sort">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">M2PKt_sort</code><span class="sig-paren">(</span><em>surfSrc</em>, <em>surfTar</em>, <em>Ktx_aux</em>, <em>Kty_aux</em>, <em>Ktz_aux</em>, <em>surf</em>, <em>index</em>, <em>param</em>, <em>LorY</em>, <em>timing</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#M2PKt_sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.M2PKt_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>It computes the far field contribution of the adjoint double potential
using the sorted data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>surfSrc</strong> (<em>class, source surface, the one that contains the gauss points.</em>) &#8211; </li>
<li><strong>surfTar</strong> (<em>class, target surface, the one that contains the collocation</em>) &#8211; points.</li>
<li><strong>Ktx_aux</strong> (<em>array, x component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>Kty_aux</strong> (<em>array, y component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>Ktz_aux</strong> (<em>array, z component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>surf</strong> (<em>int, position of the source surface in the surface array.</em>) &#8211; </li>
<li><strong>index</strong> (<em>list, pointers to the location of the mulipole of order i,j,k</em>) &#8211; in the multipole array.</li>
<li><strong>param</strong> (<em>class, parameters related to the surface.</em>) &#8211; </li>
<li><strong>LorY</strong> (<em>int, Laplace (1) or Yukawa (2).</em>) &#8211; </li>
<li><strong>timing</strong> (<em>class, it contains timing information for different parts of</em>) &#8211; the code.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>Ktx_aux</strong> (<em>array, x component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>Kty_aux</strong> (<em>array, y component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>Ktz_aux</strong> (<em>array, z component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.M2P_gpu">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">M2P_gpu</code><span class="sig-paren">(</span><em>surfSrc</em>, <em>surfTar</em>, <em>K_gpu</em>, <em>V_gpu</em>, <em>surf</em>, <em>ind0</em>, <em>param</em>, <em>LorY</em>, <em>timing</em>, <em>kernel</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#M2P_gpu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.M2P_gpu" title="Permalink to this definition">¶</a></dt>
<dd><p>It computes the far field contribution of the double and single layer
potential using the sorted data, on the GPU.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>surfSrc</strong> (<em>class, source surface, the one that contains the gauss points.</em>) &#8211; </li>
<li><strong>surfTar</strong> (<em>class, target surface, the one that contains the collocation</em>) &#8211; points.</li>
<li><strong>K_gpu</strong> (<em>array, far field contribution to the double layer potential.</em>) &#8211; </li>
<li><strong>V_gpu</strong> (<em>array, far field contribution to the single layer potential.</em>) &#8211; </li>
<li><strong>ind0</strong> (<em>list, pointers to the location of the mulipole of order i,j,k</em>) &#8211; in the multipole array.</li>
<li><strong>param</strong> (<em>class, parameters related to the surface.</em>) &#8211; </li>
<li><strong>int, Laplace (1) or Yukawa (2).</strong> (<a class="reference internal" href="pygbe.html#pygbe.classes.Field.LorY" title="pygbe.classes.Field.LorY"><em>LorY</em></a>) &#8211; </li>
<li><strong>timing</strong> (<em>class, it contains timing information for different parts of</em>) &#8211; the code.</li>
<li><strong>kernel</strong> (<em>pycuda source module.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>K_gpu</strong> (<em>array, far field contribution to the double layer potential.</em>)</li>
<li><strong>V_gpu</strong> (<em>array, far field contribution to the single layer potential.</em>)</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.M2P_nonvec">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">M2P_nonvec</code><span class="sig-paren">(</span><em>Cells</em>, <em>CJ</em>, <em>xq</em>, <em>Kval</em>, <em>Vval</em>, <em>index</em>, <em>par_reac</em>, <em>source</em>, <em>time_M2P</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#M2P_nonvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.M2P_nonvec" title="Permalink to this definition">¶</a></dt>
<dd><p>It computes the far field contribution of the double and single layer
potential without doing the assumption that all the particles in the same
twig cell have the same interaction list.</p>
<p>This is used for the calculation for the reaction potential where the
targets are the point-charges location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Cells</strong> (<em>array, cells of the tree.</em>) &#8211; </li>
<li><strong>CJ</strong> (<em>int, index of the source cell.</em>) &#8211; </li>
<li><strong>xq</strong> (<em>array, postion of the point charges.</em>) &#8211; </li>
<li><strong>Kval</strong> (<em>array, far field contribution to the double layer potential.</em>) &#8211; </li>
<li><strong>Vval</strong> (<em>array, far field contribution to the single layer potential.</em>) &#8211; </li>
<li><strong>index</strong> (<em>list, pointers to the location of the mulipole of order i,j,k</em>) &#8211; in the multipole array.</li>
<li><strong>par_reac</strong> (<em>class, fine parameters related to the surface.</em>) &#8211; </li>
<li><strong>source</strong> (<em>list, P2P interaction list, which is a list of the cells that</em>) &#8211; each charge-point interacts by P2P.</li>
<li><strong>time_M2P</strong> (<em>real, timed consumed in compute M2P_nonvec function.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>Kval</strong> (<em>array, far field contribution to the double layer potential.</em>)</li>
<li><strong>Vval</strong> (<em>array, far field contribution to the single layer potential.</em>)</li>
<li><strong>source</strong> (<em>list, P2P interaction list, which is a list of the cells that</em>) &#8211; each charge-point interacts.</li>
<li><strong>time_M2P</strong> (<em>real, time consumed in compute M2P_nonvec function.</em>)</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.M2P_sort">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">M2P_sort</code><span class="sig-paren">(</span><em>surfSrc</em>, <em>surfTar</em>, <em>K_aux</em>, <em>V_aux</em>, <em>surf</em>, <em>index</em>, <em>param</em>, <em>LorY</em>, <em>timing</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#M2P_sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.M2P_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>It computes the far field contribution of the double and single layer
potential using the sorted data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>surfSrc</strong> (<em>class, source surface, the one that contains the gauss points.</em>) &#8211; </li>
<li><strong>surfTar</strong> (<em>class, target surface, the one that contains the collocation</em>) &#8211; points.</li>
<li><strong>K_aux</strong> (<em>array, far field contribution to the double layer potential.</em>) &#8211; </li>
<li><strong>V_aux</strong> (<em>array, far field contribution to the single layer potential.</em>) &#8211; </li>
<li><strong>surf</strong> (<em>int, position of the source surface in the surface array.</em>) &#8211; </li>
<li><strong>index</strong> (<em>list, pointers to the location of the mulipole of order i,j,k</em>) &#8211; in the multipole array.</li>
<li><strong>param</strong> (<em>class, parameters related to the surface.</em>) &#8211; </li>
<li><strong>LorY</strong> (<em>int, Laplace (1) or Yukawa (2).</em>) &#8211; </li>
<li><strong>timing</strong> (<em>class, it contains timing information for different parts of</em>) &#8211; the code.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>K_aux</strong> (<em>array, far field contribution to the double layer potential.</em>)</li>
<li><strong>V_aux</strong> (<em>array, far field contribution to the single layer potential.</em>)</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.P2PKt_gpu">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">P2PKt_gpu</code><span class="sig-paren">(</span><em>surfSrc</em>, <em>surfTar</em>, <em>m</em>, <em>mKtc</em>, <em>Ktx_gpu</em>, <em>Kty_gpu</em>, <em>Ktz_gpu</em>, <em>surf</em>, <em>LorY</em>, <em>w</em>, <em>param</em>, <em>timing</em>, <em>kernel</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#P2PKt_gpu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.P2PKt_gpu" title="Permalink to this definition">¶</a></dt>
<dd><p>It computes the near field contribution of the double and single layer
potential using the sorted data and adds it to the far field contribution
given as an input, on the GPU.</p>
<p>Note: In this context when we refer to mass we mean</p>
<blockquote>
<div><blockquote>
<div>mass       = (vector x gauss weights)
mass-clean = (vector)</div></blockquote>
<p>where &#8216;vector&#8217; is the vector in the matrix-vector multiplication in
the GMRES.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>surfSrc</strong> (<em>class, source surface, the one that contains the gauss points.</em>) &#8211; </li>
<li><strong>surfTar</strong> (<em>class, target surface, the one that contains the collocation</em>) &#8211; points.</li>
<li><strong>m</strong> (<em>array, mass of the source particle for the adjoint double layer</em>) &#8211; potential calculation.</li>
<li><strong>mKc</strong> (<em>array, mass-clean of the source particle for the adjoint double</em>) &#8211; layer potential calculation.</li>
<li><strong>Ktx_gpu</strong> (<em>array, x component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>Kty_gpu</strong> (<em>array, y component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>Ktz_gpu</strong> (<em>array, z component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>surf</strong> (<em>int, position of the source surface in the surface array.</em>) &#8211; </li>
<li><strong>LorY</strong> (<em>int, Laplace (1) or Yukawa (2).</em>) &#8211; </li>
<li><strong>w</strong> (<em>array, gauss points.</em>) &#8211; </li>
<li><strong>param</strong> (<em>class, parameters related to the surface.</em>) &#8211; </li>
<li><strong>timing</strong> (<em>class, it contains timing information for different parts of</em>) &#8211; the code.</li>
<li><strong>kernel</strong> (<em>pycuda source module.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>Ktx_gpu</strong> (<em>array, x component of the far plus near field contribution to the</em>) &#8211; adjoint double layer potential.</li>
<li><strong>Kty_gpu</strong> (<em>array, y component of the far plus near field contribution to the</em>) &#8211; adjoint double layer potential.</li>
<li><strong>Ktz_gpu</strong> (<em>array, z component of the far plus near field contribution to the</em>) &#8211; adjoint double layer potential.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.P2PKt_sort">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">P2PKt_sort</code><span class="sig-paren">(</span><em>surfSrc</em>, <em>surfTar</em>, <em>m</em>, <em>mKc</em>, <em>Ktx_aux</em>, <em>Kty_aux</em>, <em>Ktz_aux</em>, <em>surf</em>, <em>LorY</em>, <em>w</em>, <em>param</em>, <em>timing</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#P2PKt_sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.P2PKt_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>It computes the near field contribution of the double and single layer
potential using the sorted data and adds it to the far field contribution
given as an input.</p>
<dl class="docutils">
<dt>Note: In this context when we refer to mass we mean</dt>
<dd><blockquote class="first">
<div>mass       = (vector x gauss weights)
mass-clean = (vector)</div></blockquote>
<p class="last">where &#8216;vector&#8217; is the vector in the matrix-vector multiplication in
the GMRES.</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>surfSrc</strong> (<em>class, source surface, the one that contains the gauss points.</em>) &#8211; </li>
<li><strong>surfTar</strong> (<em>class, target surface, the one that contains the collocation</em>) &#8211; points.</li>
<li><strong>m</strong> (<em>array, mass of the source particle for the adjoint double layer</em>) &#8211; potential calculation.</li>
<li><strong>mKc</strong> (<em>array, mass-clean of the source particle for the adjoint double</em>) &#8211; layer potential calculation.</li>
<li><strong>Ktx_aux</strong> (<em>array, x component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>Kty_aux</strong> (<em>array, y component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>Ktz_aux</strong> (<em>array, z component of the far field contribution to the adjoint</em>) &#8211; double layer potential.</li>
<li><strong>surf</strong> (<em>int, position of the source surface in the surface array.</em>) &#8211; </li>
<li><strong>LorY</strong> (<em>int, Laplace (1) or Yukawa (2).</em>) &#8211; </li>
<li><strong>w</strong> (<em>array, gauss points.</em>) &#8211; </li>
<li><strong>param</strong> (<em>class, parameters related to the surface.</em>) &#8211; </li>
<li><strong>timing</strong> (<em>class, it contains timing information for different parts of</em>) &#8211; the code.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>Ktx_aux</strong> (<em>array, x component of the far plus near field contribution to the</em>) &#8211; adjoint double layer potential.</li>
<li><strong>Kty_aux</strong> (<em>array, y component of the far plus near field contribution to the</em>) &#8211; adjoint double layer potential.</li>
<li><strong>Ktz_aux</strong> (<em>array, z component of the far plus near field contribution to the</em>) &#8211; adjoint double layer potential.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.P2P_gpu">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">P2P_gpu</code><span class="sig-paren">(</span><em>surfSrc</em>, <em>surfTar</em>, <em>m</em>, <em>mx</em>, <em>my</em>, <em>mz</em>, <em>mKc</em>, <em>mVc</em>, <em>K_gpu</em>, <em>V_gpu</em>, <em>surf</em>, <em>LorY</em>, <em>K_diag</em>, <em>IorE</em>, <em>L</em>, <em>w</em>, <em>param</em>, <em>timing</em>, <em>kernel</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#P2P_gpu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.P2P_gpu" title="Permalink to this definition">¶</a></dt>
<dd><p>It computes the near field contribution of the double and single layer
potential using the sorted data and adds it to the far field contribution
given as an input, on the GPU.</p>
<dl class="docutils">
<dt>Note: In this context when we refer to mass we mean</dt>
<dd><blockquote class="first">
<div>mass       = (vector x gauss weights)
mass-clean = (vector)</div></blockquote>
<p class="last">where &#8216;vector&#8217; is the vector in the matrix-vector multiplication in
the GMRES.</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>surfSrc</strong> (<em>class, source surface, the one that contains the gauss points.</em>) &#8211; </li>
<li><strong>surfTar</strong> (<em>class, target surface, the one that contains the collocation</em>) &#8211; points.</li>
<li><strong>m</strong> (<em>array, mass of the source particle for the single layer potential</em>) &#8211; calculation.</li>
<li><strong>mx</strong> (<em>array, mass of the source particle times  the 'x' component of the</em>) &#8211; normal vector, for the double layer potential calculation.</li>
<li><strong>my</strong> (<em>array, mass of the source particle times  the 'y' component of the</em>) &#8211; normal vector, for the double layer potential calculation.</li>
<li><strong>mz</strong> (<em>array, mass of the source particle times  the 'z' component of the</em>) &#8211; normal vector, for the double layer potential calculation.</li>
<li><strong>mKc</strong> (<em>array, mass-clean of the source particle for the double layer</em>) &#8211; potential calculation.</li>
<li><strong>mVc</strong> (<em>array, mass-clean of the source particle for the double layer</em>) &#8211; potential calculation.</li>
<li><strong>K_gpu</strong> (<em>array, far field contribution to the double layer potential.</em>) &#8211; </li>
<li><strong>V_gpu</strong> (<em>array, far field contribution to the single layer potential.</em>) &#8211; </li>
<li><strong>surf</strong> (<em>int, position of the source surface in the surface array.</em>) &#8211; </li>
<li><strong>K_diag</strong> (<em>array, diagonal elements of the double layer integral operator.</em>) &#8211; </li>
<li><strong>IorE</strong> (<em>int, internal (1) or external (2).</em>) &#8211; </li>
<li><strong>L</strong> (<em>float, representative distance of the triangles. (sqrt{2*Area})</em>) &#8211; </li>
<li><strong>w</strong> (<em>array, gauss points.</em>) &#8211; </li>
<li><strong>param</strong> (<em>class, parameters related to the surface.</em>) &#8211; </li>
<li><strong>timing</strong> (<em>class, it contains timing information for different parts of</em>) &#8211; the code.</li>
<li><strong>kernel</strong> (<em>pycuda source module.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>K_gpu</strong> (<em>array, far plus near field contribution to the double layer</em>) &#8211; potential.</li>
<li><strong>V_gpu</strong> (<em>array, far plus near field contribution to the single layer</em>) &#8211; potential.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.P2P_nonvec">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">P2P_nonvec</code><span class="sig-paren">(</span><em>Cells</em>, <em>surface</em>, <em>m</em>, <em>mx</em>, <em>my</em>, <em>mz</em>, <em>mKc</em>, <em>mVc</em>, <em>xq</em>, <em>Kval</em>, <em>Vval</em>, <em>IorE</em>, <em>par_reac</em>, <em>w</em>, <em>source</em>, <em>AI_int</em>, <em>time_P2P</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#P2P_nonvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.P2P_nonvec" title="Permalink to this definition">¶</a></dt>
<dd><p>It computes the near field contribution of the double and single layer
potential and adds it to the far field contribution given as an input.
In this case we don&#8217;t do the assumption that all the particles in the same
twig cell have the same interaction list.</p>
<p>This is used for the calculation for the reaction potential where the
targets are the point-charges location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Cells</strong> (<em>array, cells of the tree.</em>) &#8211; </li>
<li><strong>surface</strong> (<em>class, surface where we are computing the P2P_nonvec.</em>) &#8211; </li>
<li><strong>m</strong> (<em>array, mass of the source particle for the single layer potential</em>) &#8211; calculation.</li>
<li><strong>mx</strong> (<em>array, mass of the source particle times  the 'x' component of the</em>) &#8211; normal vector, for the double layer potential calculation.</li>
<li><strong>my</strong> (<em>array, mass of the source particle times  the 'y' component of the</em>) &#8211; normal vector, for the double layer potential calculation.</li>
<li><strong>mz</strong> (<em>array, mass of the source particle times  the 'z' component of the</em>) &#8211; normal vector, for the double layer potential calculation.</li>
<li><strong>mKc</strong> (<em>array, mass-clean of the source particle for the double layer</em>) &#8211; potential calculation.</li>
<li><strong>mVc</strong> (<em>array, mass-clean of the source particle for the double layer</em>) &#8211; potential calculation.</li>
<li><strong>xq</strong> (<em>array, postion of the point charges.</em>) &#8211; </li>
<li><strong>Kval</strong> (<em>array, far field contribution to the double layer potential.</em>) &#8211; </li>
<li><strong>Vval</strong> (<em>array, far field contribution to the single layer potential.</em>) &#8211; </li>
<li><strong>IorE</strong> (<em>int, internal (1) or external (2).</em>) &#8211; </li>
<li><strong>par_reac</strong> (<em>class, fine parameters related to the surface.</em>) &#8211; </li>
<li><strong>w</strong> (<em>array, gauss points.</em>) &#8211; </li>
<li><strong>source</strong> (<em>list, P2P interaction list, which is a list of the cells that</em>) &#8211; each charge-point interacts.</li>
<li><strong>AI_int</strong> (<em>int, counter of the amount of near singular integrals solved.</em>) &#8211; </li>
<li><strong>time_P2P</strong> (<em>real, timed consumed in compute P2P_nonvec function.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>Kval</strong> (<em>array, far plus near field contribution to the double layer</em>) &#8211; potential.</li>
<li><strong>Vval</strong> (<em>array, far plus near field contribution to the single layer</em>) &#8211; potential.</li>
<li><strong>AI_int</strong> (<em>int, counter of the amount of near singular integrals solved.</em>)</li>
<li><strong>time_P2P</strong> (<em>real, timed consumed in compute P2P_nonvec function.</em>)</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.P2P_sort">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">P2P_sort</code><span class="sig-paren">(</span><em>surfSrc</em>, <em>surfTar</em>, <em>m</em>, <em>mx</em>, <em>my</em>, <em>mz</em>, <em>mKc</em>, <em>mVc</em>, <em>K_aux</em>, <em>V_aux</em>, <em>surf</em>, <em>LorY</em>, <em>K_diag</em>, <em>V_diag</em>, <em>IorE</em>, <em>L</em>, <em>w</em>, <em>param</em>, <em>timing</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#P2P_sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.P2P_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>It computes the near field contribution of the double and single layer
potential using the sorted data and adds it to the far field contribution
given as an input.</p>
<dl class="docutils">
<dt>Note: In this context when we refer to mass we mean</dt>
<dd><blockquote class="first">
<div>mass       = (vector x gauss weights)
mass-clean = (vector)</div></blockquote>
<p class="last">where &#8216;vector&#8217; is the vector in the matrix-vector multiplication in
the GMRES.</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>surfSrc</strong> (<em>class, source surface, the one that contains the gauss points.</em>) &#8211; </li>
<li><strong>surfTar</strong> (<em>class, target surface, the one that contains the collocation</em>) &#8211; points.</li>
<li><strong>m</strong> (<em>array, mass of the source particle for the single layer potential</em>) &#8211; calculation.</li>
<li><strong>mx</strong> (<em>array, mass of the source particle times  the 'x' component of the</em>) &#8211; normal vector, for the double layer potential calculation.</li>
<li><strong>my</strong> (<em>array, mass of the source particle times  the 'y' component of the</em>) &#8211; normal vector, for the double layer potential calculation.</li>
<li><strong>mz</strong> (<em>array, mass of the source particle times  the 'z' component of the</em>) &#8211; normal vector, for the double layer potential calculation.</li>
<li><strong>mKc</strong> (<em>array, mass-clean of the source particle for the double layer</em>) &#8211; potential calculation.</li>
<li><strong>mVc</strong> (<em>array, mass-clean of the source particle for the double layer</em>) &#8211; potential calculation.</li>
<li><strong>K_aux</strong> (<em>array, far field contribution to the double layer potential.</em>) &#8211; </li>
<li><strong>V_aux</strong> (<em>array, far field contribution to the single layer potential.</em>) &#8211; </li>
<li><strong>surf</strong> (<em>int, position of the source surface in the surface array.</em>) &#8211; </li>
<li><strong>K_diag</strong> (<em>array, diagonal elements of the double layer integral operator.</em>) &#8211; </li>
<li><strong>V_diag</strong> (<em>array, diagonal elements of the single layer integral operator.</em>) &#8211; </li>
<li><strong>IorE</strong> (<em>int, internal (1) or external (2).</em>) &#8211; </li>
<li><strong>L</strong> (<em>float, representative distance of the triangles. (sqrt{2*Area})</em>) &#8211; </li>
<li><strong>w</strong> (<em>array, gauss points.</em>) &#8211; </li>
<li><strong>param</strong> (<em>class, parameters related to the surface.</em>) &#8211; </li>
<li><strong>timing</strong> (<em>class, it contains timing information for different parts of</em>) &#8211; the code.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>K_aux</strong> (<em>array, far plus near field contribution to the double layer</em>) &#8211; potential.</li>
<li><strong>V_aux</strong> (<em>array, far plus near field contribution to the single layer</em>) &#8211; potential.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.addSources">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">addSources</code><span class="sig-paren">(</span><em>Cells</em>, <em>twig</em>, <em>K</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#addSources"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.addSources" title="Permalink to this definition">¶</a></dt>
<dd><p>It adds the source points to the cells.
Puts the sources in the same cell as the collocation point of the same
panel.
This version works fast when used with sorted arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>Cells</strong> (<em>array, cells of the tree.</em>) &#8211; </li>
<li><strong>twig</strong> (<em>array, indices of twigs in Cells array.</em>) &#8211; </li>
<li><strong>K</strong> (<em>int, number of Gauss points per element.</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.addSources2">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">addSources2</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>j</em>, <em>Cells</em>, <em>C</em>, <em>NCRIT</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#addSources2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.addSources2" title="Permalink to this definition">¶</a></dt>
<dd><p>It adds the source points to the cells.
Puts the sources in the same cell as the collocation point of the same
panel.
This version is a generic version that loop over the cells looking for
twigs and sets the sources one it finds a twig.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>array, x coordinate of the sources.</em>) &#8211; </li>
<li><strong>y</strong> (<em>array, y coordinate of the sources.</em>) &#8211; </li>
<li><strong>z</strong> (<em>array, z coordinate of the sources.</em>) &#8211; </li>
<li><strong>j</strong> (<em>int, index of the source in the source array.</em>) &#8211; </li>
<li><strong>Cells</strong> (<em>array, cells of the tree.</em>) &#8211; </li>
<li><strong>C</strong> (<em>int, index of cell in the Cells array.</em>) &#8211; </li>
<li><strong>NCRIT</strong> (<em>int, maximum number of boundary elements per twig box of tree</em>) &#8211; structure.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.addSources3">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">addSources3</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>Cells</em>, <em>twig</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#addSources3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.addSources3" title="Permalink to this definition">¶</a></dt>
<dd><p>It adds the source points to the cells.
Puts the sources in the same cell as the collocation point of the same
panel.
This version works fast when we uses the twig_array, array that contains
the location in the cells array of the twig cells.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>array, x coordinate of the sources.</em>) &#8211; </li>
<li><strong>y</strong> (<em>array, y coordinate of the sources.</em>) &#8211; </li>
<li><strong>z</strong> (<em>array, z coordinate of the sources.</em>) &#8211; </li>
<li><strong>j</strong> (<em>int, index of the source in the source array.</em>) &#8211; </li>
<li><strong>Cells</strong> (<em>array, cells of the tree.</em>) &#8211; </li>
<li><strong>twig</strong> (<em>array, indices of twigs in Cells array.</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.add_child">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">add_child</code><span class="sig-paren">(</span><em>octant</em>, <em>Cells</em>, <em>i</em>, <em>NCRIT</em>, <em>Nm</em>, <em>Ncell</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#add_child"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.add_child" title="Permalink to this definition">¶</a></dt>
<dd><p>It adds a child cell to the Cells.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>octant</strong> (<em>int, octant of the child cell.</em>) &#8211; </li>
<li><strong>Cells</strong> (<em>array, it contains the cells information.</em>) &#8211; </li>
<li><strong>i</strong> (<em>int, index of parent cell in Cells array.</em>) &#8211; </li>
<li><strong>NCRIT</strong> (<em>int, maximum number of boundary elements per twig box of tree</em>) &#8211; structure.</li>
<li><strong>Nm</strong> (<em>int, number of multipole coefficients.</em>) &#8211; </li>
<li><strong>Ncell</strong> (<em>int, number of cells in the tree.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Ncell</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int, number of cells in the tree.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.computeIndices">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">computeIndices</code><span class="sig-paren">(</span><em>P</em>, <em>ind0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#computeIndices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.computeIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>It computes the indices (exponents) needed to compute the Taylor expansion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>P</strong> (<em>int, order of the Taylor expansion.</em>) &#8211; </li>
<li><strong>ind0</strong> (<em>class, it contains the indices related to the treecode computation.</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.findTwigs">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">findTwigs</code><span class="sig-paren">(</span><em>Cells</em>, <em>C</em>, <em>twig</em>, <em>NCRIT</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#findTwigs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.findTwigs" title="Permalink to this definition">¶</a></dt>
<dd><p>It finds the twig cells, the ones that have &lt; NCRIT.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Cells</strong> (<em>array, cells of the tree.</em>) &#8211; </li>
<li><strong>C</strong> (<em>int, index of cell in the Cells array.</em>) &#8211; </li>
<li><strong>twig</strong> (<em>array, indices of twigs in Cells array.</em>) &#8211; </li>
<li><strong>NCRIT</strong> (<em>int, maximum number of boundary elements per twig box of tree</em>) &#8211; structure.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>twig</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">array, indices of twigs in Cells array.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.generateList">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">generateList</code><span class="sig-paren">(</span><em>surf_array</em>, <em>field_array</em>, <em>param</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#generateList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.generateList" title="Permalink to this definition">¶</a></dt>
<dd><p>Loops over the surfaces to then compute the interactionList().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>surf_array</strong> (<em>array, contains the surface classes of each region on the</em>) &#8211; surface.</li>
<li><strong>field_array</strong> (<em>array, contains the Field classes of each region on the</em>) &#8211; surface.</li>
<li><strong>param</strong> (<em>class, parameters related to the surface.</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.generateTree">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">generateTree</code><span class="sig-paren">(</span><em>xi</em>, <em>yi</em>, <em>zi</em>, <em>NCRIT</em>, <em>Nm</em>, <em>N</em>, <em>radius</em>, <em>x_center</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#generateTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.generateTree" title="Permalink to this definition">¶</a></dt>
<dd><p>It generates a target-based tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xi</strong> (<em>array, x position of the targets, i.e collocation points.</em>) &#8211; </li>
<li><strong>yi</strong> (<em>array, y position of the targets, i.e collocation points.</em>) &#8211; </li>
<li><strong>zi</strong> (<em>array, z position of the targets, i.e collocation points.</em>) &#8211; </li>
<li><strong>NCRIT</strong> (<em>int, maximum number of boundary elements per twig box of tree</em>) &#8211; structure.</li>
<li><strong>Nm</strong> (<em>int, number of multipole coefficients.</em>) &#8211; </li>
<li><strong>r</strong> (<em>float, cell radius, i.e half length.</em>) &#8211; </li>
<li><strong>x_center</strong> (<em>array, center of the root cell.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Cells</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">array, cells of the tree.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.getMultipole">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">getMultipole</code><span class="sig-paren">(</span><em>Cells</em>, <em>C</em>, <em>x</em>, <em>y</em>, <em>z</em>, <em>mV</em>, <em>mKx</em>, <em>mKy</em>, <em>mKz</em>, <em>ind0</em>, <em>P</em>, <em>NCRIT</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#getMultipole"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.getMultipole" title="Permalink to this definition">¶</a></dt>
<dd><p>It gets the multipole of the twig cells.
(P2M)</p>
<dl class="docutils">
<dt>Note: In this context when we refer to mass we mean</dt>
<dd><blockquote class="first">
<div>mass  = (vector x gauss weights)</div></blockquote>
<p class="last">where &#8216;vector&#8217; is the vector in the matrix-vector multiplication in
the GMRES.</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>Cells</strong> (<em>array, it contains the cells information.</em>) &#8211; </li>
<li><strong>C</strong> (<em>int, index of the cell in the Cells array.</em>) &#8211; </li>
<li><strong>x</strong> (<em>array, x coordinate of the sources.</em>) &#8211; </li>
<li><strong>y</strong> (<em>array, y coordinate of the sources.</em>) &#8211; </li>
<li><strong>z</strong> (<em>array, z coordinate of the sources.</em>) &#8211; </li>
<li><strong>mV</strong> (<em>array, mass of the source particle for the single layer potential</em>) &#8211; calculation.</li>
<li><strong>mKx</strong> (<em>array, mass of the source particle times  the 'x' component of the</em>) &#8211; normal vector, for the double layer potential calculation.</li>
<li><strong>mKy</strong> (<em>array, mass of the source particle times  the 'y' component of the</em>) &#8211; normal vector, for the double layer potential calculation.</li>
<li><strong>mKz</strong> (<em>array, mass of the source particle times  the 'z' component of the</em>) &#8211; normal vector, for the double layer potential calculation.</li>
<li><strong>ind0</strong> (<em>class, it contains the indices related to the treecode computation.</em>) &#8211; </li>
<li><strong>P</strong> (<em>int, order of the Taylor expansion.</em>) &#8211; </li>
<li><strong>NCRIT</strong> (<em>int, maximum number of boundary elements per twig box of tree</em>) &#8211; structure.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.interactionList">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">interactionList</code><span class="sig-paren">(</span><em>surfSrc</em>, <em>surfTar</em>, <em>CJ</em>, <em>CI</em>, <em>theta</em>, <em>NCRIT</em>, <em>offTwg</em>, <em>offMlt</em>, <em>s_src</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#interactionList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.interactionList" title="Permalink to this definition">¶</a></dt>
<dd><p>It finds the list of cells which each twig cell interacts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>surfSrc</strong> (<em>class, source surface, the one that contains the gauss points.</em>) &#8211; </li>
<li><strong>surfTar</strong> (<em>class, target surface, the one that contains the collocation</em>) &#8211; points.</li>
<li><strong>CJ</strong> (<em>int, index of source cell.</em>) &#8211; </li>
<li><strong>CI</strong> (<em>int, index of target cell.</em>) &#8211; </li>
<li><strong>theta</strong> (<em>float, Multipole-acceptance criterion (MAC).</em>) &#8211; </li>
<li><strong>NCRIT</strong> (<em>int, maximum number of boundary elements per twig box of tree</em>) &#8211; structure.</li>
<li><strong>offTwg</strong> (<em>array, pointer to the first element in the array P2P_list which</em>) &#8211; contains the P2P interaction list for each twig cell.</li>
<li><strong>offMlt</strong> (<em>array, pointer to the first element in the array M2P_list which</em>) &#8211; contains the M2P interaction list for each twig cell.</li>
<li><strong>s_src</strong> (<em>int, position (index) in the surface-array of the surface that</em>) &#8211; contains the sources.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>offTwg</strong> (<em>array, pointer to the first element in the P2P interaction list</em>) &#8211; for each twig cell.</li>
<li><strong>offMlt</strong> (<em>array, pointer to the first element in the M2P interaction list</em>) &#8211; for each twig cell.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.precomputeTerms">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">precomputeTerms</code><span class="sig-paren">(</span><em>P</em>, <em>ind0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#precomputeTerms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.precomputeTerms" title="Permalink to this definition">¶</a></dt>
<dd><p>It precomputes the terms for P2M and M2M computation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>P</strong> (<em>int, order of the Taylor expansion.</em>) &#8211; </li>
<li><strong>ind0</strong> (<em>class, it contains the indices related to the treecode computation.</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.sortPoints">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">sortPoints</code><span class="sig-paren">(</span><em>surface</em>, <em>Cells</em>, <em>twig</em>, <em>param</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#sortPoints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.sortPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>It sort the target and source points.</p>
<p>We sort them to makes the computation easy and faster in the GPU.
We unsort them when we need the information to be analized after it was
computed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>surface</strong> (<em>class, surface that we are analysing.</em>) &#8211; </li>
<li><strong>Cells</strong> (<em>array, cells of the tree.</em>) &#8211; </li>
<li><strong>twig</strong> (<em>array, indices of twigs in Cells array.</em>) &#8211; </li>
<li><strong>param</strong> (<em>class, parameters related to the surface.</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.split_cell">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">split_cell</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>Cells</em>, <em>C</em>, <em>NCRIT</em>, <em>Nm</em>, <em>Ncell</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#split_cell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.split_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>It splits a cell with more than (&gt;=) NCRIT particles.
Particles in this context means boundary elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>array, x position of the particles.</em>) &#8211; </li>
<li><strong>y</strong> (<em>array, y position of the particles.</em>) &#8211; </li>
<li><strong>z</strong> (<em>array, z position of the particles.</em>) &#8211; </li>
<li><strong>Cells</strong> (<em>array, it contains the cells information.</em>) &#8211; </li>
<li><strong>C</strong> (<em>int, index in the Cells array of the cell to be splitted .</em>) &#8211; </li>
<li><strong>NCRIT</strong> (<em>int, maximum number of boundary elements per twig box of tree</em>) &#8211; structure.</li>
<li><strong>Nm</strong> (<em>int, number of multipole coefficients.</em>) &#8211; </li>
<li><strong>Ncell</strong> (<em>int, number of cells in the tree.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Ncell</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int, number of cells in the tree.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.FMMutils.upwardSweep">
<code class="descclassname">pygbe.tree.FMMutils.</code><code class="descname">upwardSweep</code><span class="sig-paren">(</span><em>Cells</em>, <em>CC</em>, <em>PC</em>, <em>P</em>, <em>II</em>, <em>JJ</em>, <em>KK</em>, <em>index</em>, <em>combII</em>, <em>combJJ</em>, <em>combKK</em>, <em>IImii</em>, <em>JJmjj</em>, <em>KKmkk</em>, <em>index_small</em>, <em>index_ptr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/FMMutils.html#upwardSweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.FMMutils.upwardSweep" title="Permalink to this definition">¶</a></dt>
<dd><p>It calculates the M2M. Calculation of the multipole for non-twig cells .</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>Cells</strong> (<em>array, it contains the cells information.</em>) &#8211; </li>
<li><strong>CC</strong> (<em>int, index of the child cell in the Cells array .</em>) &#8211; </li>
<li><strong>PC</strong> (<em>int, index of the parent cell in the Cells array</em>) &#8211; </li>
<li><strong>P</strong> (<em>int, order of the Taylor expansion.</em>) &#8211; </li>
<li><strong>II</strong> (<em>list, multipole order in the x-direction for the treecode.</em>) &#8211; </li>
<li><strong>JJ</strong> (<em>list, multipole order in the y-direction for the treecode.</em>) &#8211; </li>
<li><strong>KK</strong> (<em>list, multipole order in the z-direction for the treecode.</em>) &#8211; </li>
<li><strong>index</strong> (<em>list, pointers to the location of the mulipole of order i,j,k</em>) &#8211; in the multipole array.</li>
<li><strong>combII</strong> (<em>array, combinatory of (I, i) where I is the maximum i multipole.</em>) &#8211; </li>
<li><strong>combJJ</strong> (<em>array, combinatory of (J, j) where J is the maximum j multipole.</em>) &#8211; </li>
<li><strong>combKK</strong> (<em>array, combinatory of (K, k) where K is the maximum k multipole.</em>) &#8211; </li>
<li><strong>IImii</strong> (<em>array, I-i where I is the maximum i multipole.</em>) &#8211; </li>
<li><strong>JJmjj</strong> (<em>array, J-j where J is the maximum j multipole.</em>) &#8211; </li>
<li><strong>KKmkk</strong> (<em>array, K-k where K is the maximum k multipole.</em>) &#8211; </li>
<li><strong>index_small</strong> (<em>list, pointers to the position of multipole order i, j, k</em>) &#8211; in the multipole array, organized in a 1D array which is
compressed with respect to index_large (does not consider
combinations of i,j,k which do not have a multipole).</li>
<li><strong>index_ptr</strong> (<em>list, pointer to index_small. Data in index_small is organized</em>) &#8211; in a i-major fashion (i,j,k), and index_ptr points at the
position in index_small where the order i changes.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pygbe.tree.calculateMultipoles">
<span id="pygbe-tree-calculatemultipoles-module"></span><h2>pygbe.tree.calculateMultipoles module<a class="headerlink" href="#module-pygbe.tree.calculateMultipoles" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pygbe.tree.cuda_kernels">
<span id="pygbe-tree-cuda-kernels-module"></span><h2>pygbe.tree.cuda_kernels module<a class="headerlink" href="#module-pygbe.tree.cuda_kernels" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pygbe.tree.cuda_kernels.kernels">
<code class="descclassname">pygbe.tree.cuda_kernels.</code><code class="descname">kernels</code><span class="sig-paren">(</span><em>BSZ</em>, <em>Nm</em>, <em>K_fine</em>, <em>P</em>, <em>REAL</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/cuda_kernels.html#kernels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.cuda_kernels.kernels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pygbe.tree.direct">
<span id="pygbe-tree-direct-module"></span><h2>pygbe.tree.direct module<a class="headerlink" href="#module-pygbe.tree.direct" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pygbe.tree.multipole">
<span id="pygbe-tree-multipole-module"></span><h2>pygbe.tree.multipole module<a class="headerlink" href="#module-pygbe.tree.multipole" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pygbe.tree.octree">
<span id="pygbe-tree-octree-module"></span><h2>pygbe.tree.octree module<a class="headerlink" href="#module-pygbe.tree.octree" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pygbe.tree.octree.add_child">
<code class="descclassname">pygbe.tree.octree.</code><code class="descname">add_child</code><span class="sig-paren">(</span><em>octant</em>, <em>Cells</em>, <em>i</em>, <em>NCRIT</em>, <em>Nm</em>, <em>Ncell</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/octree.html#add_child"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.octree.add_child" title="Permalink to this definition">¶</a></dt>
<dd><p>It adds a child cell to the Cells.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>octant</strong> (<em>int, octant of the child cell.</em>) &#8211; </li>
<li><strong>Cells</strong> (<em>array, it contains the cells information.</em>) &#8211; </li>
<li><strong>i</strong> (<em>int, index of parent cell in Cells array.</em>) &#8211; </li>
<li><strong>NCRIT</strong> (<em>int, maximum number of boundary elements per twig box of tree</em>) &#8211; structure.</li>
<li><strong>Nm</strong> (<em>int, number of multipole coefficients.</em>) &#8211; </li>
<li><strong>Ncell</strong> (<em>int, number of cells in the tree.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Ncell</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int, number of cells in the tree.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.octree.generateTree">
<code class="descclassname">pygbe.tree.octree.</code><code class="descname">generateTree</code><span class="sig-paren">(</span><em>xi</em>, <em>yi</em>, <em>zi</em>, <em>NCRIT</em>, <em>Nm</em>, <em>N</em>, <em>radius</em>, <em>x_center</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/octree.html#generateTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.octree.generateTree" title="Permalink to this definition">¶</a></dt>
<dd><p>It generates a target-based tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xi</strong> (<em>array, x position of the targets, i.e collocation points.</em>) &#8211; </li>
<li><strong>yi</strong> (<em>array, y position of the targets, i.e collocation points.</em>) &#8211; </li>
<li><strong>zi</strong> (<em>array, z position of the targets, i.e collocation points.</em>) &#8211; </li>
<li><strong>NCRIT</strong> (<em>int, maximum number of boundary elements per twig box of tree</em>) &#8211; structure.</li>
<li><strong>Nm</strong> (<em>int, number of multipole coefficients.</em>) &#8211; </li>
<li><strong>r</strong> (<em>float, cell radius, i.e half length.</em>) &#8211; </li>
<li><strong>x_center</strong> (<em>array, center of the root cell.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Cells</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">array, cells of the tree.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pygbe.tree.octree.split_cell">
<code class="descclassname">pygbe.tree.octree.</code><code class="descname">split_cell</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>Cells</em>, <em>C</em>, <em>NCRIT</em>, <em>Nm</em>, <em>Ncell</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pygbe/tree/octree.html#split_cell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pygbe.tree.octree.split_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>It splits a cell with more than (&gt;=) NCRIT particles.
Particles in this context means boundary elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>array, x position of the particles.</em>) &#8211; </li>
<li><strong>y</strong> (<em>array, y position of the particles.</em>) &#8211; </li>
<li><strong>z</strong> (<em>array, z position of the particles.</em>) &#8211; </li>
<li><strong>Cells</strong> (<em>array, it contains the cells information.</em>) &#8211; </li>
<li><strong>C</strong> (<em>int, index in the Cells array of the cell to be splitted .</em>) &#8211; </li>
<li><strong>NCRIT</strong> (<em>int, maximum number of boundary elements per twig box of tree</em>) &#8211; structure.</li>
<li><strong>Nm</strong> (<em>int, number of multipole coefficients.</em>) &#8211; </li>
<li><strong>Ncell</strong> (<em>int, number of cells in the tree.</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Ncell</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">int, number of cells in the tree.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pygbe.tree">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pygbe.tree" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pygbe.tree package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-pygbe.tree.FMMutils">pygbe.tree.FMMutils module</a></li>
<li><a class="reference internal" href="#module-pygbe.tree.calculateMultipoles">pygbe.tree.calculateMultipoles module</a></li>
<li><a class="reference internal" href="#module-pygbe.tree.cuda_kernels">pygbe.tree.cuda_kernels module</a></li>
<li><a class="reference internal" href="#module-pygbe.tree.direct">pygbe.tree.direct module</a></li>
<li><a class="reference internal" href="#module-pygbe.tree.multipole">pygbe.tree.multipole module</a></li>
<li><a class="reference internal" href="#module-pygbe.tree.octree">pygbe.tree.octree module</a></li>
<li><a class="reference internal" href="#module-pygbe.tree">Module contents</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/source/pygbe.tree.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Christopher Cooper, Natalia Clementi, Gil Forsyth, Lorena Barba.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="../_sources/source/pygbe.tree.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>