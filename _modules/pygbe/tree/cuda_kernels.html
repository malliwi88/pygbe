<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pygbe.tree.cuda_kernels &mdash; PyGBe 0.2 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="PyGBe 0.2 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pygbe.tree.cuda_kernels</h1><div class="highlight"><pre>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pycuda.compiler</span> <span class="kn">import</span> <span class="n">SourceModule</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>

<div class="viewcode-block" id="kernels"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.cuda_kernels.kernels">[docs]</a><span class="k">def</span> <span class="nf">kernels</span><span class="p">(</span><span class="n">BSZ</span><span class="p">,</span> <span class="n">Nm</span><span class="p">,</span> <span class="n">K_fine</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">REAL</span><span class="p">):</span>

    <span class="n">mod</span> <span class="o">=</span> <span class="n">SourceModule</span><span class="p">(</span> <span class="s">&quot;&quot;&quot;</span>

<span class="s">    #define REAL </span><span class="si">%(precision)s</span><span class="s"></span>
<span class="s">    #define BSZ </span><span class="si">%(blocksize)d</span><span class="s"></span>
<span class="s">    #define Nm  </span><span class="si">%(Nmult)d</span><span class="s"></span>
<span class="s">    #define K_fine </span><span class="si">%(K_near)d</span><span class="s"></span>
<span class="s">    #define P      </span><span class="si">%(Ptree)d</span><span class="s"></span>


<span class="s">    /*</span>
<span class="s">    __device__ int getIndex(int P, int i, int j, int k)</span>
<span class="s">    {</span>
<span class="s">        int I=0, ii, jj;</span>
<span class="s">        for (ii=0; ii&lt;i; ii++)</span>
<span class="s">        {</span>
<span class="s">            for (jj=1; jj&lt;P+2-ii; jj++)</span>
<span class="s">            {</span>
<span class="s">                I+=jj;</span>
<span class="s">            }</span>
<span class="s">        }</span>
<span class="s">        for (jj=P+2-j; jj&lt;P+2; jj++)</span>
<span class="s">        {</span>
<span class="s">            I+=jj-i;</span>
<span class="s">        }</span>
<span class="s">        I+=k;</span>

<span class="s">        return I;</span>
<span class="s">    }</span>
<span class="s">    */</span>

<span class="s">    __device__ int getIndex(int i, int j, int k, int *Index)</span>
<span class="s">    {</span>
<span class="s">        return Index[(P+1)*(P+1)*i + (P+1)*j + k];</span>
<span class="s">    }</span>

<span class="s">    __device__ void getCoeff(REAL *a, REAL dx, REAL dy, REAL dz, REAL kappa, int *index, int LorY)</span>
<span class="s">    {</span>
<span class="s">        REAL b[Nm];</span>

<span class="s">        REAL R = sqrt(dx*dx+dy*dy+dz*dz);</span>
<span class="s">        REAL R2 = R*R;</span>
<span class="s">        REAL R3 = R2*R;</span>

<span class="s">        int i,j,k,I,Im1x,Im2x,Im1y,Im2y,Im1z,Im2z;</span>
<span class="s">        REAL C,C1,C2,Cb;</span>

<span class="s">        if (LorY==2) // if Yukawa</span>
<span class="s">        {</span>
<span class="s">            b[0] = exp(-kappa*R);</span>
<span class="s">            a[0] = b[0]/R;</span>
<span class="s">        }</span>

<span class="s">        if (LorY==1) // if Laplace</span>
<span class="s">        {</span>
<span class="s">            a[0] = 1/R;</span>
<span class="s">        }</span>

<span class="s">        // Two indices = 0</span>
<span class="s">        I = getIndex(1,0,0, index);</span>

<span class="s">        if (LorY==2) // if Yukawa</span>
<span class="s">        {</span>
<span class="s">            b[I]   = -kappa * (dx*a[0]); // 1,0,0</span>
<span class="s">            b[P+1] = -kappa * (dy*a[0]); // 0,1,0</span>
<span class="s">            b[1]   = -kappa * (dz*a[0]); // 0,0,1</span>

<span class="s">            a[I]   = -1/R2*(kappa*dx*b[0]+dx*a[0]);</span>
<span class="s">            a[P+1] = -1/R2*(kappa*dy*b[0]+dy*a[0]);</span>
<span class="s">            a[1]   = -1/R2*(kappa*dz*b[0]+dz*a[0]);</span>

<span class="s">        }</span>

<span class="s">        if (LorY==1) // if Laplace</span>
<span class="s">        {</span>
<span class="s">            a[I]   = -dx/R3;</span>
<span class="s">            a[P+1] = -dy/R3;</span>
<span class="s">            a[1]   = -dz/R3;</span>

<span class="s">        }</span>

<span class="s">        for (i=2; i&lt;P+1; i++)</span>
<span class="s">        {</span>
<span class="s">            Cb   = -kappa/i;</span>
<span class="s">            C    = 1./(i*R2);</span>
<span class="s">            I    = getIndex(i,0,0, index);</span>
<span class="s">            Im1x = getIndex(i-1,0,0, index);</span>
<span class="s">            Im2x = getIndex(i-2,0,0, index);</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dx*a[Im1x] + a[Im2x]);</span>
<span class="s">                a[I] = C * ( -kappa*(dx*b[Im1x] + b[Im2x]) -(2*i-1)*dx*a[Im1x] - (i-1)*a[Im2x] );</span>
<span class="s">            }</span>

<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*i-1)*dx*a[Im1x] - (i-1)*a[Im2x] );</span>
<span class="s">            }</span>

<span class="s">            I    = getIndex(0,i,0, index);</span>
<span class="s">            Im1y = I-(P+2-i);</span>
<span class="s">            Im2y = Im1y-(P+2-i+1);</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dy*a[Im1y] + a[Im2y]);</span>
<span class="s">                a[I] = C * ( -kappa*(dy*b[Im1y] + b[Im2y]) -(2*i-1)*dy*a[Im1y] - (i-1)*a[Im2y] );</span>
<span class="s">            }</span>
<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*i-1)*dy*a[Im1y] - (i-1)*a[Im2y] );</span>
<span class="s">            }</span>

<span class="s">            I   = i;</span>
<span class="s">            Im1z = I-1;</span>
<span class="s">            Im2z = I-2;</span>

<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dz*a[Im1z] + a[Im2z]);</span>
<span class="s">                a[I] = C * ( -kappa*(dz*b[Im1z] + b[Im2z]) -(2*i-1)*dz*a[Im1z] - (i-1)*a[Im2z] );</span>
<span class="s">            }</span>
<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*i-1)*dz*a[Im1z] - (i-1)*a[Im2z] );</span>
<span class="s">            }</span>
<span class="s">        }</span>

<span class="s">        // One index = 0, one = 1 other &gt;=1</span>

<span class="s">        Cb   = -kappa/2;</span>
<span class="s">        I    = getIndex(1,1,0, index);</span>
<span class="s">        Im1x = P+1;</span>
<span class="s">        Im1y = I-(P+2-1-1);</span>
<span class="s">        if (LorY==2) // if Yukawa</span>
<span class="s">        {</span>
<span class="s">            b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y]);</span>
<span class="s">            a[I] = 1./(2*R2) * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]) -(2*2-1)*(dx*a[Im1x]+dy*a[Im1y]) );</span>
<span class="s">        }</span>

<span class="s">        if (LorY==1) // if Laplace</span>
<span class="s">        {</span>
<span class="s">            a[I] = 1./(2*R2) * ( -(2*2-1)*(dx*a[Im1x]+dy*a[Im1y]) );</span>
<span class="s">        }</span>

<span class="s">        I    = getIndex(1,0,1, index);</span>
<span class="s">        Im1x = 1;</span>
<span class="s">        Im1z = I-1;</span>
<span class="s">        if (LorY==2) // if Yukawa</span>
<span class="s">        {</span>
<span class="s">            b[I] = Cb * (dx*a[Im1x] + dz*a[Im1z]);</span>
<span class="s">            a[I] = 1./(2*R2) * ( -kappa*(dx*b[Im1x]+dz*b[Im1z]) -(2*2-1)*(dx*a[Im1x]+dz*a[Im1z]) );</span>
<span class="s">        }</span>

<span class="s">        if (LorY==1) // if Laplace</span>
<span class="s">        {</span>
<span class="s">            a[I] = 1./(2*R2) * ( -(2*2-1)*(dx*a[Im1x]+dz*a[Im1z]) );</span>
<span class="s">        }</span>

<span class="s">        I    = getIndex(0,1,1, index);</span>
<span class="s">        Im1y = I-(P+2-1);</span>
<span class="s">        Im1z = I-1;</span>

<span class="s">        if (LorY==2) // if Yukawa</span>
<span class="s">        {</span>
<span class="s">            b[I] = Cb * (dy*a[Im1y] + dz*a[Im1z]);</span>
<span class="s">            a[I] = 1./(2*R2) * ( -kappa*(dy*b[Im1y]+dz*b[Im1z]) -(2*2-1)*(dy*a[Im1y]+dz*a[Im1z]) );</span>
<span class="s">        }</span>

<span class="s">        if (LorY==1) // if Laplace</span>
<span class="s">        {</span>
<span class="s">            a[I] = 1./(2*R2) * ( -(2*2-1)*(dy*a[Im1y]+dz*a[Im1z]) );</span>
<span class="s">        }</span>

<span class="s">        for (i=2; i&lt;P; i++)</span>
<span class="s">        {</span>
<span class="s">            Cb   = -kappa/(i+1);</span>
<span class="s">            C    = 1./((1+i)*R2);</span>
<span class="s">            I    = getIndex(1,i,0, index);</span>
<span class="s">            Im1x = getIndex(0,i,0, index);</span>
<span class="s">            Im1y = I-(P+2-i-1);</span>
<span class="s">            Im2y = Im1y-(P+2-i);</span>

<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + a[Im2y]);</span>
<span class="s">                a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+b[Im2y]) -(2*(1+i)-1)*(dx*a[Im1x]+dy*a[Im1y]) - (1+i-1)*(a[Im2y]) );</span>
<span class="s">            }</span>

<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*(1+i)-1)*(dx*a[Im1x]+dy*a[Im1y]) - (1+i-1)*(a[Im2y]) );</span>
<span class="s">            }</span>

<span class="s">            I    = getIndex(1,0,i, index);</span>
<span class="s">            Im1x = getIndex(0,0,i, index);</span>
<span class="s">            Im1z = I-1;</span>
<span class="s">            Im2z = I-2;</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dx*a[Im1x] + dz*a[Im1z] + a[Im2z]);</span>
<span class="s">                a[I] = C * ( -kappa*(dx*b[Im1x]+dz*b[Im1z]+b[Im2z]) -(2*(1+i)-1)*(dx*a[Im1x]+dz*a[Im1z]) - (1+i-1)*(a[Im2z]) );</span>
<span class="s">            }</span>

<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*(1+i)-1)*(dx*a[Im1x]+dz*a[Im1z]) - (1+i-1)*(a[Im2z]) );</span>
<span class="s">            }</span>

<span class="s">            I    = getIndex(0,1,i, index);</span>
<span class="s">            Im1y = I-(P+2-1);</span>
<span class="s">            Im1z = I-1;</span>
<span class="s">            Im2z = I-2;</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dy*a[Im1y] + dz*a[Im1z] + a[Im2z]);</span>
<span class="s">                a[I] = C * ( -kappa*(dy*b[Im1y]+dz*b[Im1z]+b[Im2z]) -(2*(1+i)-1)*(dy*a[Im1y]+dz*a[Im1z]) - (1+i-1)*(a[Im2z]) );</span>
<span class="s">            }</span>

<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*(1+i)-1)*(dy*a[Im1y]+dz*a[Im1z]) - (1+i-1)*(a[Im2z]) );</span>
<span class="s">            }</span>

<span class="s">            I    = getIndex(i,1,0, index);</span>
<span class="s">            Im1y = I-(P+2-1-i);</span>
<span class="s">            Im1x = getIndex(i-1,1,0, index);</span>
<span class="s">            Im2x = getIndex(i-2,1,0, index);</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dy*a[Im1y] + dx*a[Im1x] + a[Im2x]);</span>
<span class="s">                a[I] = C * ( -kappa*(dy*b[Im1y]+dx*b[Im1x]+b[Im2x]) -(2*(1+i)-1)*(dy*a[Im1y]+dx*a[Im1x]) - (1+i-1)*(a[Im2x]) );</span>
<span class="s">            }</span>

<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*(1+i)-1)*(dy*a[Im1y]+dx*a[Im1x]) - (1+i-1)*(a[Im2x]) );</span>
<span class="s">            }</span>

<span class="s">            I    = getIndex(i,0,1, index);</span>
<span class="s">            Im1z = I-1;</span>
<span class="s">            Im1x = getIndex(i-1,0,1, index);</span>
<span class="s">            Im2x = getIndex(i-2,0,1, index);</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dz*a[Im1z] + dx*a[Im1x] + a[Im2x]);</span>
<span class="s">                a[I] = C * ( -kappa*(dz*b[Im1z]+dx*b[Im1x]+b[Im2x]) -(2*(1+i)-1)*(dz*a[Im1z]+dx*a[Im1x]) - (1+i-1)*(a[Im2x]) );</span>
<span class="s">            }</span>
<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*(1+i)-1)*(dz*a[Im1z]+dx*a[Im1x]) - (1+i-1)*(a[Im2x]) );</span>
<span class="s">            }</span>

<span class="s">            I    = getIndex(0,i,1, index);</span>
<span class="s">            Im1z = I-1;</span>
<span class="s">            Im1y = I-(P+2-i);</span>
<span class="s">            Im2y = Im1y-(P+2-i+1);</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dz*a[Im1z] + dy*a[Im1y] + a[Im2y]);</span>
<span class="s">                a[I] = C * ( -kappa*(dz*b[Im1z]+dy*b[Im1y]+b[Im2y]) -(2*(1+i)-1)*(dz*a[Im1z]+dy*a[Im1y]) - (1+i-1)*(a[Im2y]) );</span>
<span class="s">            }</span>
<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*(1+i)-1)*(dz*a[Im1z]+dy*a[Im1y]) - (1+i-1)*(a[Im2y]) );</span>
<span class="s">            }</span>
<span class="s">        }</span>

<span class="s">        // One index 0, others &gt;=2</span>
<span class="s">        for (i=2; i&lt;P+1; i++)</span>
<span class="s">        {</span>
<span class="s">            for (j=2; j&lt;P+1-i; j++)</span>
<span class="s">            {</span>
<span class="s">                Cb   = -kappa/(i+j);</span>
<span class="s">                C    = 1./((i+j)*R2);</span>
<span class="s">                I    = getIndex(i,j,0, index);</span>
<span class="s">                Im1x = getIndex(i-1,j,0, index);</span>
<span class="s">                Im2x = getIndex(i-2,j,0, index);</span>
<span class="s">                Im1y = I-(P+2-j-i);</span>
<span class="s">                Im2y = Im1y-(P+3-j-i);</span>
<span class="s">                if (LorY==2) // if Yukawa</span>
<span class="s">                {</span>
<span class="s">                    b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + a[Im2x] + a[Im2y]);</span>
<span class="s">                    a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+b[Im2x]+b[Im2y]) -(2*(i+j)-1)*(dx*a[Im1x]+dy*a[Im1y]) -(i+j-1)*(a[Im2x]+a[Im2y]) );</span>
<span class="s">                }</span>
<span class="s">                if (LorY==1) // if Laplace</span>
<span class="s">                {</span>
<span class="s">                    a[I] = C * ( -(2*(i+j)-1)*(dx*a[Im1x]+dy*a[Im1y]) -(i+j-1)*(a[Im2x]+a[Im2y]) );</span>
<span class="s">                }</span>

<span class="s">                I    = getIndex(i,0,j, index);</span>
<span class="s">                Im1x = getIndex(i-1,0,j, index);</span>
<span class="s">                Im2x = getIndex(i-2,0,j, index);</span>
<span class="s">                Im1z = I-1;</span>
<span class="s">                Im2z = I-2;</span>
<span class="s">                if (LorY==2) // if Yukawa</span>
<span class="s">                {</span>
<span class="s">                    b[I] = Cb * (dx*a[Im1x] + dz*a[Im1z] + a[Im2x] + a[Im2z]);</span>
<span class="s">                    a[I] = C * ( -kappa*(dx*b[Im1x]+dz*b[Im1z]+b[Im2x]+b[Im2z]) -(2*(i+j)-1)*(dx*a[Im1x]+dz*a[Im1z]) -(i+j-1)*(a[Im2x]+a[Im2z]) );</span>
<span class="s">                }</span>

<span class="s">                if (LorY==1) // if Laplace</span>
<span class="s">                {</span>
<span class="s">                    a[I] = C * ( -(2*(i+j)-1)*(dx*a[Im1x]+dz*a[Im1z]) -(i+j-1)*(a[Im2x]+a[Im2z]) );</span>
<span class="s">                }</span>

<span class="s">                I    = getIndex(0,i,j, index);</span>
<span class="s">                Im1y = I-(P+2-i);</span>
<span class="s">                Im2y = Im1y-(P+3-i);</span>
<span class="s">                Im1z = I-1;</span>
<span class="s">                Im2z = I-2;</span>
<span class="s">                if (LorY==2) // if Yukawa</span>
<span class="s">                {</span>
<span class="s">                    b[I] = Cb * (dy*a[Im1y] + dz*a[Im1z] + a[Im2y] + a[Im2z]);</span>
<span class="s">                    a[I] = C * ( -kappa*(dy*b[Im1y]+dz*b[Im1z]+b[Im2y]+b[Im2z]) -(2*(i+j)-1)*(dy*a[Im1y]+dz*a[Im1z]) -(i+j-1)*(a[Im2y]+a[Im2z]) );</span>
<span class="s">                }</span>
<span class="s">                if (LorY==1) // if Laplace</span>
<span class="s">                {</span>
<span class="s">                    a[I] = C * ( -(2*(i+j)-1)*(dy*a[Im1y]+dz*a[Im1z]) -(i+j-1)*(a[Im2y]+a[Im2z]) );</span>
<span class="s">                }</span>
<span class="s">            }</span>
<span class="s">        }</span>

<span class="s">        if (P&gt;2)</span>
<span class="s">        {</span>
<span class="s">            // Two index = 1, other&gt;=1</span>
<span class="s">            Cb   = -kappa/3;</span>
<span class="s">            I    = getIndex(1,1,1, index);</span>
<span class="s">            Im1x = getIndex(0,1,1, index);</span>
<span class="s">            Im1y = getIndex(1,0,1, index);</span>
<span class="s">            Im1y = I-(P);</span>
<span class="s">            Im1z = I-1;</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z]);</span>
<span class="s">                a[I] = 1/(3*R2) * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]) -5*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) );</span>
<span class="s">            }</span>

<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = 1/(3*R2) * ( -5*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) );</span>
<span class="s">            }</span>

<span class="s">            for (i=2; i&lt;P-1; i++)</span>
<span class="s">            {</span>
<span class="s">                Cb   = -kappa/(2+i);</span>
<span class="s">                C    = 1./((i+2)*R2);</span>
<span class="s">                I    = getIndex(i,1,1, index);</span>
<span class="s">                Im1x = getIndex(i-1,1,1, index);</span>
<span class="s">                Im1y = I-(P+2-i-1);</span>
<span class="s">                Im1z = I-1;</span>
<span class="s">                Im2x = getIndex(i-2,1,1, index);</span>
<span class="s">                if (LorY==2) // if Yukawa</span>
<span class="s">                {</span>
<span class="s">                    b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2x]);</span>
<span class="s">                    a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2x]) -(2*(i+2)-1)*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - (i+1)*(a[Im2x]) );</span>
<span class="s">                }</span>
<span class="s">                if (LorY==1) // if Laplace</span>
<span class="s">                {</span>
<span class="s">                    a[I] = C * ( -(2*(i+2)-1)*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - (i+1)*(a[Im2x]) );</span>
<span class="s">                }</span>

<span class="s">                I    = getIndex(1,i,1, index);</span>
<span class="s">                Im1x = getIndex(0,i,1, index);</span>
<span class="s">                Im1y = I-(P+2-i-1);</span>
<span class="s">                Im2y = Im1y-(P+3-i-1);</span>
<span class="s">                Im1z = I-1 ;</span>
<span class="s">                if (LorY==2) // if Yukawa</span>
<span class="s">                {</span>
<span class="s">                    b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2y]);</span>
<span class="s">                    a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2y]) -(2*(i+2)-1)*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - (i+1)*(a[Im2y]) );</span>
<span class="s">                }</span>
<span class="s">                if (LorY==1) // if Laplace</span>
<span class="s">                {</span>
<span class="s">                    a[I] = C * ( -(2*(i+2)-1)*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - (i+1)*(a[Im2y]) );</span>
<span class="s">                }</span>


<span class="s">                I    = getIndex(1,1,i, index);</span>
<span class="s">                Im1x = getIndex(0,1,i, index);</span>
<span class="s">                Im1y = I-(P);</span>
<span class="s">                Im1z = I-1;</span>
<span class="s">                Im2z = I-2;</span>
<span class="s">                if (LorY==2) // if Yukawa</span>
<span class="s">                {</span>
<span class="s">                    b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2z]);</span>
<span class="s">                    a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2z]) -(2*(i+2)-1)*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - (i+1)*(a[Im2z]) );</span>
<span class="s">                }</span>
<span class="s">                if (LorY==1) // if Laplace</span>
<span class="s">                {</span>
<span class="s">                    a[I] = C * ( -(2*(i+2)-1)*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - (i+1)*(a[Im2z]) );</span>
<span class="s">                }</span>
<span class="s">            }</span>
<span class="s">        }</span>

<span class="s">        // One index = 1, others &gt;=2</span>
<span class="s">        if (P&gt;4)</span>
<span class="s">        {</span>
<span class="s">            for (i=2; i&lt;P-2; i++)</span>
<span class="s">            {</span>
<span class="s">                for (j=2; j&lt;P-i; j++)</span>
<span class="s">                {</span>
<span class="s">                    Cb = -kappa/(1+i+j);</span>
<span class="s">                    C  = 1./((1+i+j)*R2);</span>
<span class="s">                    C1 = -(2.*(1+i+j)-1);</span>
<span class="s">                    C2 = (i+j);</span>
<span class="s">                    I    = getIndex(1,i,j, index);</span>
<span class="s">                    Im1x = getIndex(0,i,j, index);</span>
<span class="s">                    Im1y = I-(P+2-1-i);</span>
<span class="s">                    Im2y = Im1y-(P+3-1-i);</span>
<span class="s">                    Im1z = I-1;</span>
<span class="s">                    Im2z = I-2;</span>
<span class="s">                    if (LorY==2) // if Yukawa</span>
<span class="s">                    {</span>
<span class="s">                        b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2y] + a[Im2z]);</span>
<span class="s">                        a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2y]+b[Im2z]) + C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2y]+a[Im2z]) );</span>
<span class="s">                    }</span>
<span class="s">                    if (LorY==1) // if Laplace</span>
<span class="s">                    {</span>
<span class="s">                        a[I] = C * ( C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2y]+a[Im2z]) );</span>
<span class="s">                    }</span>

<span class="s">                    I    = getIndex(i,1,j, index);</span>
<span class="s">                    Im1x = getIndex(i-1,1,j, index);</span>
<span class="s">                    Im1y = I-(P+2-i-1);</span>
<span class="s">                    Im2x = getIndex(i-2,1,j, index);</span>
<span class="s">                    Im1z = I-1;</span>
<span class="s">                    Im2z = I-2;</span>
<span class="s">                    if (LorY==2) // if Yukawa</span>
<span class="s">                    {</span>
<span class="s">                        b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2x] + a[Im2z]);</span>
<span class="s">                        a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2x]+b[Im2z]) + C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2x]+a[Im2z]) );</span>
<span class="s">                    }</span>
<span class="s">                    if (LorY==1) // if Laplace</span>
<span class="s">                    {</span>
<span class="s">                        a[I] = C * ( C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2x]+a[Im2z]) );</span>
<span class="s">                    }</span>

<span class="s">                    I    = getIndex(i,j,1, index);</span>
<span class="s">                    Im1x = getIndex(i-1,j,1, index);</span>
<span class="s">                    Im2x = getIndex(i-2,j,1, index);</span>
<span class="s">                    Im1y = I-(P+2-i-j);</span>
<span class="s">                    Im2y = Im1y-(P+3-i-j);</span>
<span class="s">                    Im1z = I-1;</span>
<span class="s">                    if (LorY==2) // if Yukawa</span>
<span class="s">                    {</span>
<span class="s">                        b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2x] + a[Im2y]);</span>
<span class="s">                        a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2x]+b[Im2y]) + C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2x]+a[Im2y]) );</span>
<span class="s">                    }</span>
<span class="s">                    if (LorY==1) // if Laplace</span>
<span class="s">                    {</span>
<span class="s">                        a[I] = C * ( C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2x]+a[Im2y]) );</span>
<span class="s">                    }</span>
<span class="s">                }</span>
<span class="s">            }</span>
<span class="s">        }</span>

<span class="s">        // All indices &gt;= 2</span>
<span class="s">        if (P&gt;5)</span>
<span class="s">        {</span>
<span class="s">            for (i=2;i&lt;P-3;i++)</span>
<span class="s">            {</span>
<span class="s">                for (j=2;j&lt;P-1-i;j++)</span>
<span class="s">                {</span>
<span class="s">                    for (k=2;k&lt;P+1-i-j;k++)</span>
<span class="s">                    {</span>
<span class="s">                        Cb = -kappa/(i+j+k);</span>
<span class="s">                        C  = 1./((i+j+k)*R2);</span>
<span class="s">                        C1 = -(2.*(i+j+k)-1);</span>
<span class="s">                        C2 = i+j+k-1.;</span>
<span class="s">                        I    = getIndex(i,j,k, index);</span>
<span class="s">                        Im1x = getIndex(i-1,j,k, index);</span>
<span class="s">                        Im2x = getIndex(i-2,j,k, index);</span>
<span class="s">                        Im1y = I-(P+2-i-j);</span>
<span class="s">                        Im2y = Im1y-(P+3-i-j);</span>
<span class="s">                        Im1z = I-1;</span>
<span class="s">                        Im2z = I-2;</span>
<span class="s">                        if (LorY==2) // if Yukawa</span>
<span class="s">                        {</span>
<span class="s">                            b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2x] + a[Im2y] + a[Im2z]);</span>
<span class="s">                            a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2x]+b[Im2y]+b[Im2z]) + C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2x]+a[Im2y]+a[Im2z]) );</span>
<span class="s">                        }</span>

<span class="s">                        if (LorY==1) // if Laplace</span>
<span class="s">                        {</span>
<span class="s">                            a[I] = C * ( C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2x]+a[Im2y]+a[Im2z]) );</span>
<span class="s">                        }</span>
<span class="s">                    }</span>
<span class="s">                }</span>
<span class="s">            }</span>
<span class="s">        }</span>
<span class="s">    }</span>

<span class="s">    __device__ void getCoeff_shift(REAL *ax, REAL *ay, REAL *az, REAL dx, REAL dy, REAL dz, REAL kappa, int *index, int LorY)</span>
<span class="s">    {</span>
<span class="s">        REAL b[Nm], a[Nm];</span>

<span class="s">        REAL R = sqrt(dx*dx+dy*dy+dz*dz);</span>
<span class="s">        REAL R2 = R*R;</span>
<span class="s">        REAL R3 = R2*R;</span>

<span class="s">        int i,j,k,I,Im1x,Im2x,Im1y,Im2y,Im1z,Im2z;</span>
<span class="s">        REAL C,C1,C2,Cb;</span>

<span class="s">        if (LorY==2) // if Yukawa</span>
<span class="s">        {</span>
<span class="s">            b[0] = exp(-kappa*R);</span>
<span class="s">            a[0] = b[0]/R;</span>
<span class="s">        }</span>

<span class="s">        if (LorY==1) // if Laplace</span>
<span class="s">        {</span>
<span class="s">            a[0] = 1/R;</span>
<span class="s">        }</span>

<span class="s">        // Two indices = 0</span>
<span class="s">        I = getIndex(1,0,0, index);</span>

<span class="s">        if (LorY==2) // if Yukawa</span>
<span class="s">        {</span>
<span class="s">            b[I]   = -kappa * (dx*a[0]); // 1,0,0</span>
<span class="s">            b[P+1] = -kappa * (dy*a[0]); // 0,1,0</span>
<span class="s">            b[1]   = -kappa * (dz*a[0]); // 0,0,1</span>

<span class="s">            a[I]   = -1/R2*(kappa*dx*b[0]+dx*a[0]);</span>
<span class="s">            a[P+1] = -1/R2*(kappa*dy*b[0]+dy*a[0]);</span>
<span class="s">            a[1]   = -1/R2*(kappa*dz*b[0]+dz*a[0]);</span>

<span class="s">        }</span>

<span class="s">        if (LorY==1) // if Laplace</span>
<span class="s">        {</span>
<span class="s">            a[I]   = -dx/R3;</span>
<span class="s">            a[P+1] = -dy/R3;</span>
<span class="s">            a[1]   = -dz/R3;</span>

<span class="s">        }</span>

<span class="s">        ax[0] = a[I];</span>
<span class="s">        ay[0] = a[P+1];</span>
<span class="s">        az[0] = a[1];</span>

<span class="s">        for (i=2; i&lt;P+1; i++)</span>
<span class="s">        {</span>
<span class="s">            Cb   = -kappa/i;</span>
<span class="s">            C    = 1./(i*R2);</span>
<span class="s">            I    = getIndex(i,0,0, index);</span>
<span class="s">            Im1x = getIndex(i-1,0,0, index);</span>
<span class="s">            Im2x = getIndex(i-2,0,0, index);</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dx*a[Im1x] + a[Im2x]);</span>
<span class="s">                a[I] = C * ( -kappa*(dx*b[Im1x] + b[Im2x]) -(2*i-1)*dx*a[Im1x] - (i-1)*a[Im2x] );</span>
<span class="s">            }</span>

<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*i-1)*dx*a[Im1x] - (i-1)*a[Im2x] );</span>
<span class="s">            }</span>

<span class="s">            ax[Im1x] = a[I]*i;</span>

<span class="s">            I    = getIndex(0,i,0, index);</span>
<span class="s">            Im1y = I-(P+2-i);</span>
<span class="s">            Im2y = Im1y-(P+2-i+1);</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dy*a[Im1y] + a[Im2y]);</span>
<span class="s">                a[I] = C * ( -kappa*(dy*b[Im1y] + b[Im2y]) -(2*i-1)*dy*a[Im1y] - (i-1)*a[Im2y] );</span>
<span class="s">            }</span>
<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*i-1)*dy*a[Im1y] - (i-1)*a[Im2y] );</span>
<span class="s">            }</span>

<span class="s">            ay[Im1y] = a[I]*i;</span>

<span class="s">            I   = i;</span>
<span class="s">            Im1z = I-1;</span>
<span class="s">            Im2z = I-2;</span>

<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dz*a[Im1z] + a[Im2z]);</span>
<span class="s">                a[I] = C * ( -kappa*(dz*b[Im1z] + b[Im2z]) -(2*i-1)*dz*a[Im1z] - (i-1)*a[Im2z] );</span>
<span class="s">            }</span>
<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*i-1)*dz*a[Im1z] - (i-1)*a[Im2z] );</span>
<span class="s">            }</span>

<span class="s">            az[Im1z] = a[I]*i;</span>
<span class="s">        }</span>

<span class="s">        // One index = 0, one = 1 other &gt;=1</span>

<span class="s">        Cb   = -kappa/2;</span>
<span class="s">        I    = getIndex(1,1,0, index);</span>
<span class="s">        Im1x = P+1;</span>
<span class="s">        Im1y = I-(P+2-1-1);</span>
<span class="s">        if (LorY==2) // if Yukawa</span>
<span class="s">        {</span>
<span class="s">            b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y]);</span>
<span class="s">            a[I] = 1./(2*R2) * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]) -(2*2-1)*(dx*a[Im1x]+dy*a[Im1y]) );</span>
<span class="s">        }</span>

<span class="s">        if (LorY==1) // if Laplace</span>
<span class="s">        {</span>
<span class="s">            a[I] = 1./(2*R2) * ( -(2*2-1)*(dx*a[Im1x]+dy*a[Im1y]) );</span>
<span class="s">        }</span>

<span class="s">        ax[Im1x] = a[I];</span>
<span class="s">        ay[Im1y] = a[I];</span>

<span class="s">        I    = getIndex(1,0,1, index);</span>
<span class="s">        Im1x = 1;</span>
<span class="s">        Im1z = I-1;</span>
<span class="s">        if (LorY==2) // if Yukawa</span>
<span class="s">        {</span>
<span class="s">            b[I] = Cb * (dx*a[Im1x] + dz*a[Im1z]);</span>
<span class="s">            a[I] = 1./(2*R2) * ( -kappa*(dx*b[Im1x]+dz*b[Im1z]) -(2*2-1)*(dx*a[Im1x]+dz*a[Im1z]) );</span>
<span class="s">        }</span>

<span class="s">        if (LorY==1) // if Laplace</span>
<span class="s">        {</span>
<span class="s">            a[I] = 1./(2*R2) * ( -(2*2-1)*(dx*a[Im1x]+dz*a[Im1z]) );</span>
<span class="s">        }</span>

<span class="s">        ax[Im1x] = a[I];</span>
<span class="s">        az[Im1z] = a[I];</span>

<span class="s">        I    = getIndex(0,1,1, index);</span>
<span class="s">        Im1y = I-(P+2-1);</span>
<span class="s">        Im1z = I-1;</span>

<span class="s">        if (LorY==2) // if Yukawa</span>
<span class="s">        {</span>
<span class="s">            b[I] = Cb * (dy*a[Im1y] + dz*a[Im1z]);</span>
<span class="s">            a[I] = 1./(2*R2) * ( -kappa*(dy*b[Im1y]+dz*b[Im1z]) -(2*2-1)*(dy*a[Im1y]+dz*a[Im1z]) );</span>
<span class="s">        }</span>

<span class="s">        if (LorY==1) // if Laplace</span>
<span class="s">        {</span>
<span class="s">            a[I] = 1./(2*R2) * ( -(2*2-1)*(dy*a[Im1y]+dz*a[Im1z]) );</span>
<span class="s">        }</span>

<span class="s">        ay[Im1y] = a[I];</span>
<span class="s">        az[Im1z] = a[I];</span>

<span class="s">        for (i=2; i&lt;P; i++)</span>
<span class="s">        {</span>
<span class="s">            Cb   = -kappa/(i+1);</span>
<span class="s">            C    = 1./((1+i)*R2);</span>
<span class="s">            I    = getIndex(1,i,0, index);</span>
<span class="s">            Im1x = getIndex(0,i,0, index);</span>
<span class="s">            Im1y = I-(P+2-i-1);</span>
<span class="s">            Im2y = Im1y-(P+2-i);</span>

<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + a[Im2y]);</span>
<span class="s">                a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+b[Im2y]) -(2*(1+i)-1)*(dx*a[Im1x]+dy*a[Im1y]) - (1+i-1)*(a[Im2y]) );</span>
<span class="s">            }</span>

<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*(1+i)-1)*(dx*a[Im1x]+dy*a[Im1y]) - (1+i-1)*(a[Im2y]) );</span>
<span class="s">            }</span>

<span class="s">            ax[Im1x] = a[I];</span>
<span class="s">            ay[Im1y] = a[I];</span>

<span class="s">            I    = getIndex(1,0,i, index);</span>
<span class="s">            Im1x = getIndex(0,0,i, index);</span>
<span class="s">            Im1z = I-1;</span>
<span class="s">            Im2z = I-2;</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dx*a[Im1x] + dz*a[Im1z] + a[Im2z]);</span>
<span class="s">                a[I] = C * ( -kappa*(dx*b[Im1x]+dz*b[Im1z]+b[Im2z]) -(2*(1+i)-1)*(dx*a[Im1x]+dz*a[Im1z]) - (1+i-1)*(a[Im2z]) );</span>
<span class="s">            }</span>

<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*(1+i)-1)*(dx*a[Im1x]+dz*a[Im1z]) - (1+i-1)*(a[Im2z]) );</span>
<span class="s">            }</span>

<span class="s">            ax[Im1x] = a[I];</span>
<span class="s">            az[Im1z] = a[I]*i;</span>

<span class="s">            I    = getIndex(0,1,i, index);</span>
<span class="s">            Im1y = I-(P+2-1);</span>
<span class="s">            Im1z = I-1;</span>
<span class="s">            Im2z = I-2;</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dy*a[Im1y] + dz*a[Im1z] + a[Im2z]);</span>
<span class="s">                a[I] = C * ( -kappa*(dy*b[Im1y]+dz*b[Im1z]+b[Im2z]) -(2*(1+i)-1)*(dy*a[Im1y]+dz*a[Im1z]) - (1+i-1)*(a[Im2z]) );</span>
<span class="s">            }</span>

<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*(1+i)-1)*(dy*a[Im1y]+dz*a[Im1z]) - (1+i-1)*(a[Im2z]) );</span>
<span class="s">            }</span>

<span class="s">            ay[Im1y] = a[I];</span>
<span class="s">            az[Im1z] = a[I]*i;</span>

<span class="s">            I    = getIndex(i,1,0, index);</span>
<span class="s">            Im1y = I-(P+2-1-i);</span>
<span class="s">            Im1x = getIndex(i-1,1,0, index);</span>
<span class="s">            Im2x = getIndex(i-2,1,0, index);</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dy*a[Im1y] + dx*a[Im1x] + a[Im2x]);</span>
<span class="s">                a[I] = C * ( -kappa*(dy*b[Im1y]+dx*b[Im1x]+b[Im2x]) -(2*(1+i)-1)*(dy*a[Im1y]+dx*a[Im1x]) - (1+i-1)*(a[Im2x]) );</span>
<span class="s">            }</span>

<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*(1+i)-1)*(dy*a[Im1y]+dx*a[Im1x]) - (1+i-1)*(a[Im2x]) );</span>
<span class="s">            }</span>

<span class="s">            ay[Im1y] = a[I];</span>
<span class="s">            ax[Im1x] = a[I]*i;</span>

<span class="s">            I    = getIndex(i,0,1, index);</span>
<span class="s">            Im1z = I-1;</span>
<span class="s">            Im1x = getIndex(i-1,0,1, index);</span>
<span class="s">            Im2x = getIndex(i-2,0,1, index);</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dz*a[Im1z] + dx*a[Im1x] + a[Im2x]);</span>
<span class="s">                a[I] = C * ( -kappa*(dz*b[Im1z]+dx*b[Im1x]+b[Im2x]) -(2*(1+i)-1)*(dz*a[Im1z]+dx*a[Im1x]) - (1+i-1)*(a[Im2x]) );</span>
<span class="s">            }</span>
<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*(1+i)-1)*(dz*a[Im1z]+dx*a[Im1x]) - (1+i-1)*(a[Im2x]) );</span>
<span class="s">            }</span>

<span class="s">            az[Im1z] = a[I];</span>
<span class="s">            ax[Im1x] = a[I]*i;</span>

<span class="s">            I    = getIndex(0,i,1, index);</span>
<span class="s">            Im1z = I-1;</span>
<span class="s">            Im1y = I-(P+2-i);</span>
<span class="s">            Im2y = Im1y-(P+2-i+1);</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dz*a[Im1z] + dy*a[Im1y] + a[Im2y]);</span>
<span class="s">                a[I] = C * ( -kappa*(dz*b[Im1z]+dy*b[Im1y]+b[Im2y]) -(2*(1+i)-1)*(dz*a[Im1z]+dy*a[Im1y]) - (1+i-1)*(a[Im2y]) );</span>
<span class="s">            }</span>
<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = C * ( -(2*(1+i)-1)*(dz*a[Im1z]+dy*a[Im1y]) - (1+i-1)*(a[Im2y]) );</span>
<span class="s">            }</span>

<span class="s">            az[Im1z] = a[I];</span>
<span class="s">            ay[Im1y] = a[I]*i;</span>

<span class="s">        }</span>

<span class="s">        // One index 0, others &gt;=2</span>
<span class="s">        for (i=2; i&lt;P+1; i++)</span>
<span class="s">        {</span>
<span class="s">            for (j=2; j&lt;P+1-i; j++)</span>
<span class="s">            {</span>
<span class="s">                Cb   = -kappa/(i+j);</span>
<span class="s">                C    = 1./((i+j)*R2);</span>
<span class="s">                I    = getIndex(i,j,0, index);</span>
<span class="s">                Im1x = getIndex(i-1,j,0, index);</span>
<span class="s">                Im2x = getIndex(i-2,j,0, index);</span>
<span class="s">                Im1y = I-(P+2-j-i);</span>
<span class="s">                Im2y = Im1y-(P+3-j-i);</span>
<span class="s">                if (LorY==2) // if Yukawa</span>
<span class="s">                {</span>
<span class="s">                    b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + a[Im2x] + a[Im2y]);</span>
<span class="s">                    a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+b[Im2x]+b[Im2y]) -(2*(i+j)-1)*(dx*a[Im1x]+dy*a[Im1y]) -(i+j-1)*(a[Im2x]+a[Im2y]) );</span>
<span class="s">                }</span>
<span class="s">                if (LorY==1) // if Laplace</span>
<span class="s">                {</span>
<span class="s">                    a[I] = C * ( -(2*(i+j)-1)*(dx*a[Im1x]+dy*a[Im1y]) -(i+j-1)*(a[Im2x]+a[Im2y]) );</span>
<span class="s">                }</span>

<span class="s">                ax[Im1x] = a[I]*i;</span>
<span class="s">                ay[Im1y] = a[I]*j;</span>

<span class="s">                I    = getIndex(i,0,j, index);</span>
<span class="s">                Im1x = getIndex(i-1,0,j, index);</span>
<span class="s">                Im2x = getIndex(i-2,0,j, index);</span>
<span class="s">                Im1z = I-1;</span>
<span class="s">                Im2z = I-2;</span>
<span class="s">                if (LorY==2) // if Yukawa</span>
<span class="s">                {</span>
<span class="s">                    b[I] = Cb * (dx*a[Im1x] + dz*a[Im1z] + a[Im2x] + a[Im2z]);</span>
<span class="s">                    a[I] = C * ( -kappa*(dx*b[Im1x]+dz*b[Im1z]+b[Im2x]+b[Im2z]) -(2*(i+j)-1)*(dx*a[Im1x]+dz*a[Im1z]) -(i+j-1)*(a[Im2x]+a[Im2z]) );</span>
<span class="s">                }</span>

<span class="s">                if (LorY==1) // if Laplace</span>
<span class="s">                {</span>
<span class="s">                    a[I] = C * ( -(2*(i+j)-1)*(dx*a[Im1x]+dz*a[Im1z]) -(i+j-1)*(a[Im2x]+a[Im2z]) );</span>
<span class="s">                }</span>

<span class="s">                ax[Im1x] = a[I]*i;</span>
<span class="s">                az[Im1z] = a[I]*j;</span>

<span class="s">                I    = getIndex(0,i,j, index);</span>
<span class="s">                Im1y = I-(P+2-i);</span>
<span class="s">                Im2y = Im1y-(P+3-i);</span>
<span class="s">                Im1z = I-1;</span>
<span class="s">                Im2z = I-2;</span>
<span class="s">                if (LorY==2) // if Yukawa</span>
<span class="s">                {</span>
<span class="s">                    b[I] = Cb * (dy*a[Im1y] + dz*a[Im1z] + a[Im2y] + a[Im2z]);</span>
<span class="s">                    a[I] = C * ( -kappa*(dy*b[Im1y]+dz*b[Im1z]+b[Im2y]+b[Im2z]) -(2*(i+j)-1)*(dy*a[Im1y]+dz*a[Im1z]) -(i+j-1)*(a[Im2y]+a[Im2z]) );</span>
<span class="s">                }</span>
<span class="s">                if (LorY==1) // if Laplace</span>
<span class="s">                {</span>
<span class="s">                    a[I] = C * ( -(2*(i+j)-1)*(dy*a[Im1y]+dz*a[Im1z]) -(i+j-1)*(a[Im2y]+a[Im2z]) );</span>
<span class="s">                }</span>

<span class="s">                ay[Im1y] = a[I]*i;</span>
<span class="s">                az[Im1z] = a[I]*j;</span>

<span class="s">            }</span>
<span class="s">        }</span>

<span class="s">        if (P&gt;2)</span>
<span class="s">        {</span>
<span class="s">            // Two index = 1, other&gt;=1</span>
<span class="s">            Cb   = -kappa/3;</span>
<span class="s">            I    = getIndex(1,1,1, index);</span>
<span class="s">            Im1x = getIndex(0,1,1, index);</span>
<span class="s">            Im1y = getIndex(1,0,1, index);</span>
<span class="s">            Im1y = I-(P);</span>
<span class="s">            Im1z = I-1;</span>
<span class="s">            if (LorY==2) // if Yukawa</span>
<span class="s">            {</span>
<span class="s">                b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z]);</span>
<span class="s">                a[I] = 1/(3*R2) * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]) -5*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) );</span>
<span class="s">            }</span>

<span class="s">            if (LorY==1) // if Laplace</span>
<span class="s">            {</span>
<span class="s">                a[I] = 1/(3*R2) * ( -5*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) );</span>
<span class="s">            }</span>

<span class="s">            ax[Im1x] = a[I];</span>
<span class="s">            ay[Im1y] = a[I];</span>
<span class="s">            az[Im1z] = a[I];</span>

<span class="s">            for (i=2; i&lt;P-1; i++)</span>
<span class="s">            {</span>
<span class="s">                Cb   = -kappa/(2+i);</span>
<span class="s">                C    = 1./((i+2)*R2);</span>
<span class="s">                I    = getIndex(i,1,1, index);</span>
<span class="s">                Im1x = getIndex(i-1,1,1, index);</span>
<span class="s">                Im1y = I-(P+2-i-1);</span>
<span class="s">                Im1z = I-1;</span>
<span class="s">                Im2x = getIndex(i-2,1,1, index);</span>
<span class="s">                if (LorY==2) // if Yukawa</span>
<span class="s">                {</span>
<span class="s">                    b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2x]);</span>
<span class="s">                    a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2x]) -(2*(i+2)-1)*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - (i+1)*(a[Im2x]) );</span>
<span class="s">                }</span>
<span class="s">                if (LorY==1) // if Laplace</span>
<span class="s">                {</span>
<span class="s">                    a[I] = C * ( -(2*(i+2)-1)*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - (i+1)*(a[Im2x]) );</span>
<span class="s">                }</span>

<span class="s">                ax[Im1x] = a[I]*i;</span>
<span class="s">                ay[Im1y] = a[I];</span>
<span class="s">                az[Im1z] = a[I];</span>

<span class="s">                I    = getIndex(1,i,1, index);</span>
<span class="s">                Im1x = getIndex(0,i,1, index);</span>
<span class="s">                Im1y = I-(P+2-i-1);</span>
<span class="s">                Im2y = Im1y-(P+3-i-1);</span>
<span class="s">                Im1z = I-1 ;</span>
<span class="s">                if (LorY==2) // if Yukawa</span>
<span class="s">                {</span>
<span class="s">                    b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2y]);</span>
<span class="s">                    a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2y]) -(2*(i+2)-1)*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - (i+1)*(a[Im2y]) );</span>
<span class="s">                }</span>
<span class="s">                if (LorY==1) // if Laplace</span>
<span class="s">                {</span>
<span class="s">                    a[I] = C * ( -(2*(i+2)-1)*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - (i+1)*(a[Im2y]) );</span>
<span class="s">                }</span>

<span class="s">                ax[Im1x] = a[I];</span>
<span class="s">                ay[Im1y] = a[I]*i;</span>
<span class="s">                az[Im1z] = a[I];</span>

<span class="s">                I    = getIndex(1,1,i, index);</span>
<span class="s">                Im1x = getIndex(0,1,i, index);</span>
<span class="s">                Im1y = I-(P);</span>
<span class="s">                Im1z = I-1;</span>
<span class="s">                Im2z = I-2;</span>
<span class="s">                if (LorY==2) // if Yukawa</span>
<span class="s">                {</span>
<span class="s">                    b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2z]);</span>
<span class="s">                    a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2z]) -(2*(i+2)-1)*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - (i+1)*(a[Im2z]) );</span>
<span class="s">                }</span>
<span class="s">                if (LorY==1) // if Laplace</span>
<span class="s">                {</span>
<span class="s">                    a[I] = C * ( -(2*(i+2)-1)*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - (i+1)*(a[Im2z]) );</span>
<span class="s">                }</span>

<span class="s">                ax[Im1x] = a[I];</span>
<span class="s">                ay[Im1y] = a[I];</span>
<span class="s">                az[Im1z] = a[I]*i;</span>

<span class="s">            }</span>
<span class="s">        }</span>

<span class="s">        // One index = 1, others &gt;=2</span>
<span class="s">        if (P&gt;4)</span>
<span class="s">        {</span>
<span class="s">            for (i=2; i&lt;P-2; i++)</span>
<span class="s">            {</span>
<span class="s">                for (j=2; j&lt;P-i; j++)</span>
<span class="s">                {</span>
<span class="s">                    Cb = -kappa/(1+i+j);</span>
<span class="s">                    C  = 1./((1+i+j)*R2);</span>
<span class="s">                    C1 = -(2.*(1+i+j)-1);</span>
<span class="s">                    C2 = (i+j);</span>
<span class="s">                    I    = getIndex(1,i,j, index);</span>
<span class="s">                    Im1x = getIndex(0,i,j, index);</span>
<span class="s">                    Im1y = I-(P+2-1-i);</span>
<span class="s">                    Im2y = Im1y-(P+3-1-i);</span>
<span class="s">                    Im1z = I-1;</span>
<span class="s">                    Im2z = I-2;</span>
<span class="s">                    if (LorY==2) // if Yukawa</span>
<span class="s">                    {</span>
<span class="s">                        b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2y] + a[Im2z]);</span>
<span class="s">                        a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2y]+b[Im2z]) + C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2y]+a[Im2z]) );</span>
<span class="s">                    }</span>
<span class="s">                    if (LorY==1) // if Laplace</span>
<span class="s">                    {</span>
<span class="s">                        a[I] = C * ( C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2y]+a[Im2z]) );</span>
<span class="s">                    }</span>

<span class="s">                    ax[Im1x] = a[I];</span>
<span class="s">                    ay[Im1y] = a[I]*i;</span>
<span class="s">                    az[Im1z] = a[I]*j;</span>

<span class="s">                    I    = getIndex(i,1,j, index);</span>
<span class="s">                    Im1x = getIndex(i-1,1,j, index);</span>
<span class="s">                    Im1y = I-(P+2-i-1);</span>
<span class="s">                    Im2x = getIndex(i-2,1,j, index);</span>
<span class="s">                    Im1z = I-1;</span>
<span class="s">                    Im2z = I-2;</span>
<span class="s">                    if (LorY==2) // if Yukawa</span>
<span class="s">                    {</span>
<span class="s">                        b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2x] + a[Im2z]);</span>
<span class="s">                        a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2x]+b[Im2z]) + C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2x]+a[Im2z]) );</span>
<span class="s">                    }</span>
<span class="s">                    if (LorY==1) // if Laplace</span>
<span class="s">                    {</span>
<span class="s">                        a[I] = C * ( C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2x]+a[Im2z]) );</span>
<span class="s">                    }</span>

<span class="s">                    ax[Im1x] = a[I]*i;</span>
<span class="s">                    ay[Im1y] = a[I];</span>
<span class="s">                    az[Im1z] = a[I]*j;</span>

<span class="s">                    I    = getIndex(i,j,1, index);</span>
<span class="s">                    Im1x = getIndex(i-1,j,1, index);</span>
<span class="s">                    Im2x = getIndex(i-2,j,1, index);</span>
<span class="s">                    Im1y = I-(P+2-i-j);</span>
<span class="s">                    Im2y = Im1y-(P+3-i-j);</span>
<span class="s">                    Im1z = I-1;</span>
<span class="s">                    if (LorY==2) // if Yukawa</span>
<span class="s">                    {</span>
<span class="s">                        b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2x] + a[Im2y]);</span>
<span class="s">                        a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2x]+b[Im2y]) + C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2x]+a[Im2y]) );</span>
<span class="s">                    }</span>
<span class="s">                    if (LorY==1) // if Laplace</span>
<span class="s">                    {</span>
<span class="s">                        a[I] = C * ( C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2x]+a[Im2y]) );</span>
<span class="s">                    }</span>

<span class="s">                    ax[Im1x] = a[I]*i;</span>
<span class="s">                    ay[Im1y] = a[I]*j;</span>
<span class="s">                    az[Im1z] = a[I];</span>

<span class="s">                }</span>
<span class="s">            }</span>
<span class="s">        }</span>

<span class="s">        // All indices &gt;= 2</span>
<span class="s">        if (P&gt;5)</span>
<span class="s">        {</span>
<span class="s">            for (i=2;i&lt;P-3;i++)</span>
<span class="s">            {</span>
<span class="s">                for (j=2;j&lt;P-1-i;j++)</span>
<span class="s">                {</span>
<span class="s">                    for (k=2;k&lt;P+1-i-j;k++)</span>
<span class="s">                    {</span>
<span class="s">                        Cb = -kappa/(i+j+k);</span>
<span class="s">                        C  = 1./((i+j+k)*R2);</span>
<span class="s">                        C1 = -(2.*(i+j+k)-1);</span>
<span class="s">                        C2 = i+j+k-1.;</span>
<span class="s">                        I    = getIndex(i,j,k, index);</span>
<span class="s">                        Im1x = getIndex(i-1,j,k, index);</span>
<span class="s">                        Im2x = getIndex(i-2,j,k, index);</span>
<span class="s">                        Im1y = I-(P+2-i-j);</span>
<span class="s">                        Im2y = Im1y-(P+3-i-j);</span>
<span class="s">                        Im1z = I-1;</span>
<span class="s">                        Im2z = I-2;</span>
<span class="s">                        if (LorY==2) // if Yukawa</span>
<span class="s">                        {</span>
<span class="s">                            b[I] = Cb * (dx*a[Im1x] + dy*a[Im1y] + dz*a[Im1z] + a[Im2x] + a[Im2y] + a[Im2z]);</span>
<span class="s">                            a[I] = C * ( -kappa*(dx*b[Im1x]+dy*b[Im1y]+dz*b[Im1z]+b[Im2x]+b[Im2y]+b[Im2z]) + C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2x]+a[Im2y]+a[Im2z]) );</span>
<span class="s">                        }</span>

<span class="s">                        if (LorY==1) // if Laplace</span>
<span class="s">                        {</span>
<span class="s">                            a[I] = C * ( C1*(dx*a[Im1x]+dy*a[Im1y]+dz*a[Im1z]) - C2*(a[Im2x]+a[Im2y]+a[Im2z]) );</span>
<span class="s">                        }</span>

<span class="s">                        ax[Im1x] = a[I]*i;</span>
<span class="s">                        ay[Im1y] = a[I]*j;</span>
<span class="s">                        az[Im1z] = a[I]*k;</span>

<span class="s">                    }</span>
<span class="s">                }</span>
<span class="s">            }</span>
<span class="s">        }</span>
<span class="s">    }</span>

<span class="s">    __device__ void multipole(REAL &amp;K, REAL &amp;V, REAL *M, REAL *Md,</span>
<span class="s">                            REAL *a, int CJ_start, int jblock, int j)</span>
<span class="s">    {</span>
<span class="s">        int offset;</span>
<span class="s">        for (int i=0; i&lt;Nm; i++)</span>
<span class="s">        {</span>
<span class="s">            offset = (CJ_start+j)*Nm + jblock*BSZ*Nm + i;</span>
<span class="s">            V += M[offset] * a[i];</span>
<span class="s">            K += Md[offset]* a[i];</span>
<span class="s">        }</span>

<span class="s">    }</span>

<span class="s">    __device__ void multipoleKt(REAL &amp;Ktx, REAL &amp;Kty, REAL &amp;Ktz, REAL *M,</span>
<span class="s">                            REAL *ax, REAL *ay, REAL *az, int CJ_start, int jblock, int j)</span>
<span class="s">    {</span>
<span class="s">        int offset;</span>
<span class="s">        for (int i=0; i&lt;Nm; i++)</span>
<span class="s">        {</span>
<span class="s">            offset = (CJ_start+j)*Nm + jblock*BSZ*Nm + i;</span>
<span class="s">            Ktx += M[offset] * ax[i];</span>
<span class="s">            Kty += M[offset] * ay[i];</span>
<span class="s">            Ktz += M[offset] * az[i];</span>
<span class="s">        }</span>

<span class="s">    }</span>

<span class="s">    __device__ REAL mynorm(REAL *x)</span>
<span class="s">    {</span>
<span class="s">        return sqrt(x[0]*x[0] + x[1]*x[1] + x[2]*x[2]);</span>
<span class="s">    }</span>

<span class="s">    __device__ void cross(REAL *x, REAL *y, REAL *z) // z is the resulting array</span>
<span class="s">    {</span>
<span class="s">        z[0] = x[1]*y[2] - x[2]*y[1];</span>
<span class="s">        z[1] = x[2]*y[0] - x[0]*y[2];</span>
<span class="s">        z[2] = x[0]*y[1] - x[1]*y[0];</span>
<span class="s">    }</span>

<span class="s">    __device__ void MV(REAL *M, REAL *V, REAL *res) // 3x3 mat-vec</span>
<span class="s">    {</span>
<span class="s">        REAL V2[3] = {V[0], V[1], V[2]};</span>
<span class="s">        for (int i=0; i&lt;3; i++)</span>
<span class="s">        {</span>
<span class="s">            REAL sum = 0.;</span>
<span class="s">            for (int j=0; j&lt;3; j++)</span>
<span class="s">            {</span>
<span class="s">                sum += M[3*i+j]*V2[j];</span>
<span class="s">            }</span>
<span class="s">            res[i] = sum;</span>
<span class="s">        }</span>
<span class="s">    }</span>

<span class="s">    __device__ void MVip(REAL *M, REAL *V) // 3x3 mat-vec in-place</span>
<span class="s">    {</span>
<span class="s">        REAL V2[3] = {V[0], V[1], V[2]};</span>
<span class="s">        for (int i=0; i&lt;3; i++)</span>
<span class="s">        {</span>
<span class="s">            REAL sum = 0.;</span>
<span class="s">            for (int j=0; j&lt;3; j++)</span>
<span class="s">            {</span>
<span class="s">                sum += M[3*i+j]*V2[j];</span>
<span class="s">            }</span>
<span class="s">            V[i] = sum;</span>
<span class="s">        }</span>
<span class="s">    }</span>

<span class="s">    __device__ REAL dot_prod(REAL *x, REAL *y) // len(3) vector dot product</span>
<span class="s">    {</span>
<span class="s">        return x[0]*y[0] + x[1]*y[1] + x[2]*y[2];</span>
<span class="s">    }</span>

<span class="s">    __device__ void axpy(REAL *x, REAL *y, REAL *z, REAL alpha, int sign, int N)</span>
<span class="s">    {</span>
<span class="s">        for(int i=0; i&lt;N; i++)</span>
<span class="s">        {</span>
<span class="s">            z[i] = sign*alpha*x[i] + y[i];</span>
<span class="s">        }</span>
<span class="s">    }</span>

<span class="s">    __device__ void ax(REAL *x, REAL *y, REAL alpha, int N)</span>
<span class="s">    {</span>
<span class="s">        for(int i=0; i&lt;N; i++)</span>
<span class="s">        {</span>
<span class="s">            y[i] = alpha*x[i];</span>
<span class="s">        }</span>

<span class="s">    }</span>

<span class="s">    __device__ void axip(REAL *x, REAL alpha, int N)</span>
<span class="s">    {</span>
<span class="s">        for(int i=0; i&lt;N; i++)</span>
<span class="s">        {</span>
<span class="s">            x[i] = alpha*x[i];</span>
<span class="s">        }</span>

<span class="s">    }</span>

<span class="s">    __device__ void lineInt(REAL &amp;PHI_K, REAL &amp;PHI_V, REAL z, REAL x, REAL v1, REAL v2, REAL kappa, REAL *xk, REAL *wk, int K, int LorY)</span>
<span class="s">    {</span>
<span class="s">        REAL theta1 = atan2(v1,x);</span>
<span class="s">        REAL theta2 = atan2(v2,x);</span>

<span class="s">        REAL absZ = fabs(z), signZ;</span>
<span class="s">        if (absZ&lt;1e-10) signZ = 0;</span>
<span class="s">        else            signZ = z/absZ;</span>

<span class="s">        // Loop over gauss points</span>
<span class="s">        REAL thetak, Rtheta, R, expKr, expKz = exp(-kappa*absZ);</span>
<span class="s">        for (int i=0; i&lt;K; i++)</span>
<span class="s">        {</span>
<span class="s">            thetak = (theta2 - theta1)/2*xk[i] + (theta2 + theta1)/2;</span>
<span class="s">            Rtheta = x/cos(thetak);</span>
<span class="s">            R      = sqrt(Rtheta*Rtheta + z*z);</span>
<span class="s">            expKr  = exp(-kappa*R);</span>
<span class="s">            if (LorY==2)</span>
<span class="s">            {</span>
<span class="s">                if (kappa&gt;1e-12)</span>
<span class="s">                {</span>
<span class="s">                    PHI_V+= -wk[i]*(expKr - expKz)/kappa * (theta2 - theta1)/2;</span>
<span class="s">                    PHI_K+=  wk[i]*(z/R*expKr - expKz*signZ) * (theta2 - theta1)/2;</span>
<span class="s">                }</span>
<span class="s">                else</span>
<span class="s">                {</span>
<span class="s">                    PHI_V+= wk[i]*(R-absZ) * (theta2 - theta1)/2;</span>
<span class="s">                    PHI_K+= wk[i]*(z/R - signZ) * (theta2 - theta1)/2;</span>
<span class="s">                }</span>
<span class="s">            }</span>

<span class="s">            if (LorY==1)</span>
<span class="s">            {</span>
<span class="s">                PHI_V += wk[i]*(R-absZ) * (theta2 - theta1)/2;</span>
<span class="s">                PHI_K += wk[i]*(z/R - signZ) * (theta2 - theta1)/2;</span>
<span class="s">            }</span>
<span class="s">        }</span>
<span class="s">    }</span>

<span class="s">    __device__ void intSide(REAL &amp;PHI_K, REAL &amp;PHI_V, REAL *v1, REAL *v2, REAL p, REAL kappa, REAL *xk, REAL *wk, int K, int LorY)</span>
<span class="s">    {</span>
<span class="s">        REAL v21u[3];</span>
<span class="s">        for (int i=0; i&lt;3; i++)</span>
<span class="s">        {</span>
<span class="s">            v21u[i] = v2[i] - v1[i];</span>
<span class="s">        }</span>

<span class="s">        REAL L21 = mynorm(v21u);</span>
<span class="s">        axip(v21u, 1/L21, 3);</span>

<span class="s">        REAL unit[3] = {0.,0.,1.};</span>
<span class="s">        REAL orthog[3];</span>
<span class="s">        cross(unit, v21u, orthog);</span>

<span class="s">        REAL v1new_x = dot_prod(orthog, v1);</span>
<span class="s">        REAL v1new_y = dot_prod(v21u, v1);</span>

<span class="s">        if (v1new_x&lt;0)</span>
<span class="s">        {</span>
<span class="s">            axip(v21u, -1, 3);</span>
<span class="s">            axip(orthog, -1, 3);</span>
<span class="s">            v1new_x = dot_prod(orthog, v1);</span>
<span class="s">            v1new_y = dot_prod(v21u, v1);</span>
<span class="s">        }</span>

<span class="s">        REAL v2new_y = dot_prod(v21u, v2);</span>

<span class="s">        if ((v1new_y&gt;0 &amp;&amp; v2new_y&lt;0) || (v1new_y&lt;0 &amp;&amp; v2new_y&gt;0))</span>
<span class="s">        {</span>
<span class="s">            lineInt(PHI_K, PHI_V, p, v1new_x, 0, v1new_y, kappa, xk, wk, K, LorY);</span>
<span class="s">            lineInt(PHI_K, PHI_V, p, v1new_x, v2new_y, 0, kappa, xk, wk, K, LorY);</span>

<span class="s">        }</span>
<span class="s">        else</span>
<span class="s">        {</span>
<span class="s">            REAL PHI_Kaux = 0., PHI_Vaux = 0.;</span>
<span class="s">            lineInt(PHI_Kaux, PHI_Vaux, p, v1new_x, v1new_y, v2new_y, kappa, xk, wk, K, LorY);</span>

<span class="s">            PHI_K -= PHI_Kaux;</span>
<span class="s">            PHI_V -= PHI_Vaux;</span>
<span class="s">        }</span>
<span class="s">    }</span>

<span class="s">    __device__ void SA(REAL &amp;PHI_K, REAL &amp;PHI_V, REAL *y, REAL x0, REAL x1, REAL x2,</span>
<span class="s">                       REAL K_diag, REAL V_diag, REAL kappa, int same, REAL *xk, REAL *wk, int K, int LorY)</span>
<span class="s">    {</span>
<span class="s">        REAL y0_panel[3], y1_panel[3], y2_panel[3], x_panel[3];</span>
<span class="s">        REAL X[3], Y[3], Z[3];</span>

<span class="s">        x_panel[0] = x0 - y[0];</span>
<span class="s">        x_panel[1] = x1 - y[1];</span>
<span class="s">        x_panel[2] = x2 - y[2];</span>
<span class="s">        for (int i=0; i&lt;3; i++)</span>
<span class="s">        {</span>
<span class="s">            y0_panel[i] = 0.;</span>
<span class="s">            y1_panel[i] = y[3+i] - y[i];</span>
<span class="s">            y2_panel[i] = y[6+i] - y[i];</span>
<span class="s">            X[i] = y1_panel[i];</span>
<span class="s">        }</span>


<span class="s">        // Find panel coordinate system X: 0-&gt;1</span>
<span class="s">        cross(y1_panel, y2_panel, Z);</span>
<span class="s">        REAL Xnorm = mynorm(X);</span>
<span class="s">        REAL Znorm = mynorm(Z);</span>
<span class="s">        for (int i=0; i&lt;3; i++)</span>
<span class="s">        {</span>
<span class="s">            X[i] /= Xnorm;</span>
<span class="s">            Z[i] /= Znorm;</span>
<span class="s">        }</span>

<span class="s">        cross(Z,X,Y);</span>

<span class="s">        // Rotate the coordinate system to match panel plane</span>
<span class="s">        // Multiply y_panel times a rotation matrix [X; Y; Z]</span>
<span class="s">        REAL x_aux, y_aux, z_aux;</span>
<span class="s">        x_aux = dot_prod(X, y0_panel);</span>
<span class="s">        y_aux = dot_prod(Y, y0_panel);</span>
<span class="s">        z_aux = dot_prod(Z, y0_panel);</span>
<span class="s">        y0_panel[0] = x_aux;</span>
<span class="s">        y0_panel[1] = y_aux;</span>
<span class="s">        y0_panel[2] = z_aux;</span>

<span class="s">        x_aux = dot_prod(X, y1_panel);</span>
<span class="s">        y_aux = dot_prod(Y, y1_panel);</span>
<span class="s">        z_aux = dot_prod(Z, y1_panel);</span>
<span class="s">        y1_panel[0] = x_aux;</span>
<span class="s">        y1_panel[1] = y_aux;</span>
<span class="s">        y1_panel[2] = z_aux;</span>

<span class="s">        x_aux = dot_prod(X, y2_panel);</span>
<span class="s">        y_aux = dot_prod(Y, y2_panel);</span>
<span class="s">        z_aux = dot_prod(Z, y2_panel);</span>
<span class="s">        y2_panel[0] = x_aux;</span>
<span class="s">        y2_panel[1] = y_aux;</span>
<span class="s">        y2_panel[2] = z_aux;</span>

<span class="s">        x_aux = dot_prod(X, x_panel);</span>
<span class="s">        y_aux = dot_prod(Y, x_panel);</span>
<span class="s">        z_aux = dot_prod(Z, x_panel);</span>
<span class="s">        x_panel[0] = x_aux;</span>
<span class="s">        x_panel[1] = y_aux;</span>
<span class="s">        x_panel[2] = z_aux;</span>

<span class="s">        // Shift origin so it matches collocation point</span>
<span class="s">        for (int i=0; i&lt;2; i++)</span>
<span class="s">        {</span>
<span class="s">            y0_panel[i] -= x_panel[i];</span>
<span class="s">            y1_panel[i] -= x_panel[i];</span>
<span class="s">            y2_panel[i] -= x_panel[i];</span>
<span class="s">        }</span>

<span class="s">        // Loop over sides</span>
<span class="s">        intSide(PHI_K, PHI_V, y0_panel, y1_panel, x_panel[2], kappa, xk, wk, K, LorY); // Side 0</span>
<span class="s">        intSide(PHI_K, PHI_V, y1_panel, y2_panel, x_panel[2], kappa, xk, wk, K, LorY); // Side 1</span>
<span class="s">        intSide(PHI_K, PHI_V, y2_panel, y0_panel, x_panel[2], kappa, xk, wk, K, LorY); // Side 2</span>

<span class="s">        if (same==1)</span>
<span class="s">        {</span>
<span class="s">            PHI_K += K_diag;</span>
<span class="s">            PHI_V += V_diag;</span>
<span class="s">        }</span>

<span class="s">    }</span>

<span class="s">    __device__ __inline__ void GQ_fine(REAL &amp;PHI_K, REAL &amp;PHI_V, REAL *panel, int J, REAL xi, REAL yi, REAL zi,</span>
<span class="s">                            REAL kappa, REAL *Xk, REAL *Wk, REAL *Area, int LorY)</span>
<span class="s">    {</span>
<span class="s">        REAL nx, ny, nz;</span>
<span class="s">        REAL dx, dy, dz, r, aux;</span>

<span class="s">        PHI_K = 0.;</span>
<span class="s">        PHI_V = 0.;</span>
<span class="s">        int j = J/9;</span>

<span class="s">        aux = 1/(2*Area[j]);</span>
<span class="s">        nx = ((panel[J+4]-panel[J+1])*(panel[J+2]-panel[J+8]) - (panel[J+5]-panel[J+2])*(panel[J+1]-panel[J+7])) * aux;</span>
<span class="s">        ny = ((panel[J+5]-panel[J+2])*(panel[J+0]-panel[J+6]) - (panel[J+3]-panel[J+0])*(panel[J+2]-panel[J+8])) * aux;</span>
<span class="s">        nz = ((panel[J+3]-panel[J+0])*(panel[J+1]-panel[J+7]) - (panel[J+4]-panel[J+1])*(panel[J+0]-panel[J+6])) * aux;</span>

<span class="s">        #pragma unroll</span>
<span class="s">        for (int kk=0; kk&lt;K_fine; kk++)</span>
<span class="s">        {</span>
<span class="s">            dx = xi - (panel[J+0]*Xk[3*kk] + panel[J+3]*Xk[3*kk+1] + panel[J+6]*Xk[3*kk+2]);</span>
<span class="s">            dy = yi - (panel[J+1]*Xk[3*kk] + panel[J+4]*Xk[3*kk+1] + panel[J+7]*Xk[3*kk+2]);</span>
<span class="s">            dz = zi - (panel[J+2]*Xk[3*kk] + panel[J+5]*Xk[3*kk+1] + panel[J+8]*Xk[3*kk+2]);</span>
<span class="s">            r   = rsqrt(dx*dx + dy*dy + dz*dz); // r is 1/r!!!</span>

<span class="s">            if (LorY==1)</span>
<span class="s">            {</span>
<span class="s">                aux = Wk[kk]*Area[j]*r;</span>
<span class="s">                PHI_V += aux;</span>
<span class="s">                PHI_K += aux*(nx*dx+ny*dy+nz*dz)*(r*r);</span>
<span class="s">            }</span>

<span class="s">            else</span>
<span class="s">            {</span>
<span class="s">                aux = Wk[kk]*Area[j]*exp(-kappa*1/r)*r;</span>
<span class="s">                PHI_V += aux;</span>
<span class="s">                PHI_K += aux*(nx*dx+ny*dy+nz*dz)*r*(kappa+r);</span>
<span class="s">            }</span>

<span class="s">        }</span>
<span class="s">    }</span>


<span class="s">    __device__ __inline__ void GQ_fineKt(REAL &amp;PHI_Ktx, REAL &amp;PHI_Kty, REAL &amp;PHI_Ktz, REAL *panel, int J,</span>
<span class="s">                            REAL xi, REAL yi, REAL zi, REAL kappa, REAL *Xk, REAL *Wk, REAL *Area, int LorY)</span>
<span class="s">    {</span>
<span class="s">        REAL dx, dy, dz, r, aux;</span>

<span class="s">        PHI_Ktx = 0.;</span>
<span class="s">        PHI_Kty = 0.;</span>
<span class="s">        PHI_Ktz = 0.;</span>
<span class="s">        int j = J/9;</span>

<span class="s">        #pragma unroll</span>
<span class="s">        for (int kk=0; kk&lt;K_fine; kk++)</span>
<span class="s">        {</span>
<span class="s">            dx = xi - (panel[J+0]*Xk[3*kk] + panel[J+3]*Xk[3*kk+1] + panel[J+6]*Xk[3*kk+2]);</span>
<span class="s">            dy = yi - (panel[J+1]*Xk[3*kk] + panel[J+4]*Xk[3*kk+1] + panel[J+7]*Xk[3*kk+2]);</span>
<span class="s">            dz = zi - (panel[J+2]*Xk[3*kk] + panel[J+5]*Xk[3*kk+1] + panel[J+8]*Xk[3*kk+2]);</span>
<span class="s">            r   = rsqrt(dx*dx + dy*dy + dz*dz); // r is 1/r!!!</span>

<span class="s">            if (LorY==1)</span>
<span class="s">            {</span>
<span class="s">                aux = Wk[kk]*Area[j]*r*r*r;</span>
<span class="s">                PHI_Ktx -= aux*dx;</span>
<span class="s">                PHI_Kty -= aux*dy;</span>
<span class="s">                PHI_Ktz -= aux*dz;</span>
<span class="s">            }</span>

<span class="s">            else</span>
<span class="s">            {</span>
<span class="s">                aux = Wk[kk]*Area[j]*exp(-kappa*1/r)*r*r*(kappa+r);</span>
<span class="s">                PHI_Ktx -= aux*dx;</span>
<span class="s">                PHI_Kty -= aux*dy;</span>
<span class="s">                PHI_Ktz -= aux*dz;</span>
<span class="s">            }</span>
<span class="s">        }</span>
<span class="s">    }</span>


<span class="s">    __global__ void M2P(REAL *K_gpu, REAL *V_gpu, int *offMlt, int *sizeTar, REAL *xc, REAL *yc, REAL *zc,</span>
<span class="s">                        REAL *M, REAL *Md, REAL *xt, REAL *yt, REAL *zt,</span>
<span class="s">                        int *Index, int ptr_off, int ptr_lst, REAL kappa, int BpT, int NCRIT, int LorY)</span>
<span class="s">    {</span>
<span class="s">        int I = threadIdx.x + blockIdx.x*NCRIT;</span>
<span class="s">        int CJ_start = offMlt[ptr_off+blockIdx.x];</span>
<span class="s">        int Nmlt     = offMlt[ptr_off+blockIdx.x+1] - CJ_start;</span>


<span class="s">        REAL xi, yi, zi,</span>
<span class="s">             dx, dy, dz;</span>
<span class="s">        REAL a[Nm];</span>

<span class="s">        __shared__ REAL xc_sh[BSZ],</span>
<span class="s">                        yc_sh[BSZ],</span>
<span class="s">                        zc_sh[BSZ];</span>
<span class="s">        __shared__ int Index_sh[(P+1)*(P+1)*(P+1)];</span>

<span class="s">        for (int ind=0; ind&lt;((P+1)*(P+1)*(P+1)-1)/BSZ; ind++)</span>
<span class="s">        {</span>
<span class="s">            Index_sh[ind*BSZ + threadIdx.x] = Index[ind*BSZ + threadIdx.x];</span>
<span class="s">        }</span>

<span class="s">        int ind = ((P+1)*(P+1)*(P+1)-1)/BSZ;</span>
<span class="s">        if (threadIdx.x&lt;(P+1)*(P+1)*(P+1)-BSZ*ind)</span>
<span class="s">        {</span>
<span class="s">            Index_sh[ind*BSZ + threadIdx.x] = Index[ind*BSZ + threadIdx.x];</span>
<span class="s">        }</span>
<span class="s">        int i;</span>


<span class="s">        for (int iblock=0; iblock&lt;BpT; iblock++)</span>
<span class="s">        {</span>
<span class="s">            i  = I + iblock*BSZ;</span>
<span class="s">            xi = xt[i];</span>
<span class="s">            yi = yt[i];</span>
<span class="s">            zi = zt[i];</span>

<span class="s">            REAL K = 0., V = 0.;</span>

<span class="s">            for(int jblock=0; jblock&lt;(Nmlt-1)/BSZ; jblock++)</span>
<span class="s">            {</span>
<span class="s">                __syncthreads();</span>
<span class="s">                xc_sh[threadIdx.x] = xc[ptr_lst + CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                yc_sh[threadIdx.x] = yc[ptr_lst + CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                zc_sh[threadIdx.x] = zc[ptr_lst + CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                __syncthreads();</span>

<span class="s">                if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">                {</span>
<span class="s">                    for (int j=0; j&lt;BSZ; j++)</span>
<span class="s">                    {</span>
<span class="s">                        dx = xi - xc_sh[j];</span>
<span class="s">                        dy = yi - yc_sh[j];</span>
<span class="s">                        dz = zi - zc_sh[j];</span>
<span class="s">                        getCoeff(a, dx, dy, dz,</span>
<span class="s">                                kappa, Index_sh, LorY);</span>
<span class="s">                        multipole(K, V, M, Md, a,</span>
<span class="s">                                CJ_start, jblock, j);</span>
<span class="s">                    }</span>
<span class="s">                }</span>
<span class="s">            }</span>

<span class="s">            __syncthreads();</span>
<span class="s">            int jblock = (Nmlt-1)/BSZ;</span>
<span class="s">            xc_sh[threadIdx.x] = xc[ptr_lst + CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">            yc_sh[threadIdx.x] = yc[ptr_lst + CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">            zc_sh[threadIdx.x] = zc[ptr_lst + CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">            __syncthreads();</span>

<span class="s">            if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">            {</span>
<span class="s">                for (int j=0; j&lt;Nmlt-(jblock*BSZ); j++)</span>
<span class="s">                {</span>
<span class="s">                    dx = xi - xc_sh[j];</span>
<span class="s">                    dy = yi - yc_sh[j];</span>
<span class="s">                    dz = zi - zc_sh[j];</span>
<span class="s">                    getCoeff(a, dx, dy, dz,</span>
<span class="s">                            kappa, Index_sh, LorY);</span>
<span class="s">                    multipole(K, V, M, Md, a,</span>
<span class="s">                            CJ_start, jblock, j);</span>
<span class="s">                }</span>
<span class="s">            }</span>

<span class="s">            if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">            {</span>
<span class="s">                K_gpu[i] += K;</span>
<span class="s">                V_gpu[i] += V;</span>
<span class="s">            }</span>
<span class="s">        }</span>

<span class="s">    }</span>

<span class="s">    __global__ void M2PKt(REAL *Ktx_gpu, REAL *Kty_gpu, REAL *Ktz_gpu,</span>
<span class="s">                        int *offMlt, int *sizeTar, REAL *xc, REAL *yc, REAL *zc,</span>
<span class="s">                        REAL *M, REAL *xt, REAL *yt, REAL *zt,</span>
<span class="s">                        int *Index, int ptr_off, int ptr_lst, REAL kappa, int BpT, int NCRIT, int LorY)</span>
<span class="s">    {</span>
<span class="s">        int I = threadIdx.x + blockIdx.x*NCRIT;</span>
<span class="s">        int CJ_start = offMlt[ptr_off+blockIdx.x];</span>
<span class="s">        int Nmlt     = offMlt[ptr_off+blockIdx.x+1] - CJ_start;</span>


<span class="s">        REAL xi, yi, zi,</span>
<span class="s">             dx, dy, dz;</span>
<span class="s">        REAL ax[Nm], ay[Nm], az[Nm];</span>

<span class="s">        __shared__ REAL xc_sh[BSZ],</span>
<span class="s">                        yc_sh[BSZ],</span>
<span class="s">                        zc_sh[BSZ];</span>
<span class="s">        __shared__ int Index_sh[(P+1)*(P+1)*(P+1)];</span>

<span class="s">        for (int ind=0; ind&lt;((P+1)*(P+1)*(P+1)-1)/BSZ; ind++)</span>
<span class="s">        {</span>
<span class="s">            Index_sh[ind*BSZ + threadIdx.x] = Index[ind*BSZ + threadIdx.x];</span>
<span class="s">        }</span>

<span class="s">        int ind = ((P+1)*(P+1)*(P+1)-1)/BSZ;</span>
<span class="s">        if (threadIdx.x&lt;(P+1)*(P+1)*(P+1)-BSZ*ind)</span>
<span class="s">        {</span>
<span class="s">            Index_sh[ind*BSZ + threadIdx.x] = Index[ind*BSZ + threadIdx.x];</span>
<span class="s">        }</span>
<span class="s">        int i;</span>


<span class="s">        for (int iblock=0; iblock&lt;BpT; iblock++)</span>
<span class="s">        {</span>
<span class="s">            i  = I + iblock*BSZ;</span>
<span class="s">            xi = xt[i];</span>
<span class="s">            yi = yt[i];</span>
<span class="s">            zi = zt[i];</span>

<span class="s">            REAL Ktx = 0., Kty = 0., Ktz = 0.;</span>

<span class="s">            for(int jblock=0; jblock&lt;(Nmlt-1)/BSZ; jblock++)</span>
<span class="s">            {</span>
<span class="s">                __syncthreads();</span>
<span class="s">                xc_sh[threadIdx.x] = xc[ptr_lst + CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                yc_sh[threadIdx.x] = yc[ptr_lst + CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                zc_sh[threadIdx.x] = zc[ptr_lst + CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                __syncthreads();</span>

<span class="s">                if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">                {</span>
<span class="s">                    for (int j=0; j&lt;BSZ; j++)</span>
<span class="s">                    {</span>
<span class="s">                        for (int ii=0; ii&lt;Nm; ii++)</span>
<span class="s">                        {</span>
<span class="s">                            ax[ii] = 0.;</span>
<span class="s">                            ay[ii] = 0.;</span>
<span class="s">                            az[ii] = 0.;</span>
<span class="s">                        }</span>

<span class="s">                        dx = xi - xc_sh[j];</span>
<span class="s">                        dy = yi - yc_sh[j];</span>
<span class="s">                        dz = zi - zc_sh[j];</span>
<span class="s">                        getCoeff_shift(ax, ay, az, dx, dy, dz,</span>
<span class="s">                                kappa, Index_sh, LorY);</span>
<span class="s">                        multipoleKt(Ktx, Kty, Ktz, M, ax, ay, az,</span>
<span class="s">                                CJ_start, jblock, j);</span>
<span class="s">                    }</span>
<span class="s">                }</span>
<span class="s">            }</span>

<span class="s">            __syncthreads();</span>
<span class="s">            int jblock = (Nmlt-1)/BSZ;</span>
<span class="s">            xc_sh[threadIdx.x] = xc[ptr_lst + CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">            yc_sh[threadIdx.x] = yc[ptr_lst + CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">            zc_sh[threadIdx.x] = zc[ptr_lst + CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">            __syncthreads();</span>

<span class="s">            if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">            {</span>
<span class="s">                for (int j=0; j&lt;Nmlt-(jblock*BSZ); j++)</span>
<span class="s">                {</span>
<span class="s">                    for (int ii=0; ii&lt;Nm; ii++)</span>
<span class="s">                    {</span>
<span class="s">                        ax[ii] = 0.;</span>
<span class="s">                        ay[ii] = 0.;</span>
<span class="s">                        az[ii] = 0.;</span>
<span class="s">                    }</span>

<span class="s">                    dx = xi - xc_sh[j];</span>
<span class="s">                    dy = yi - yc_sh[j];</span>
<span class="s">                    dz = zi - zc_sh[j];</span>
<span class="s">                    getCoeff_shift(ax, ay, az, dx, dy, dz,</span>
<span class="s">                            kappa, Index_sh, LorY);</span>
<span class="s">                    multipoleKt(Ktx, Kty, Ktz, M, ax, ay, az,</span>
<span class="s">                            CJ_start, jblock, j);</span>
<span class="s">                }</span>
<span class="s">            }</span>

<span class="s">            if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">            {</span>
<span class="s">                Ktx_gpu[i] += Ktx;</span>
<span class="s">                Kty_gpu[i] += Kty;</span>
<span class="s">                Ktz_gpu[i] += Ktz;</span>
<span class="s">            }</span>
<span class="s">        }</span>

<span class="s">    }</span>


<span class="s">    __global__ void P2P(REAL *K_gpu, REAL *V_gpu, int *offSrc, int *offTwg, int *P2P_list, int *sizeTar, int *k,</span>
<span class="s">                        REAL *xj, REAL *yj, REAL *zj, REAL *m, REAL *mx, REAL *my, REAL *mz, REAL *mKc, REAL *mVc,</span>
<span class="s">                        REAL *xt, REAL *yt, REAL *zt, REAL *Area, REAL *sglInt, REAL *vertex,</span>
<span class="s">                        int ptr_off, int ptr_lst, int LorY, REAL kappa, REAL threshold,</span>
<span class="s">                        int BpT, int NCRIT, REAL K_diag, int *AI_int_gpu, REAL *Xsk, REAL *Wsk)</span>
<span class="s">    {</span>
<span class="s">        int I = threadIdx.x + blockIdx.x*NCRIT;</span>
<span class="s">        int list_start = offTwg[ptr_off+blockIdx.x];</span>
<span class="s">        int list_end   = offTwg[ptr_off+blockIdx.x+1];</span>

<span class="s">        REAL xi, yi, zi, dx, dy, dz, r, auxK, auxV;</span>

<span class="s">        __shared__ REAL ver_sh[9*BSZ],</span>
<span class="s">                        xj_sh[BSZ], yj_sh[BSZ], zj_sh[BSZ], A_sh[BSZ], k_sh[BSZ], sglInt_sh[BSZ],</span>
<span class="s">                        m_sh[BSZ], mx_sh[BSZ], my_sh[BSZ], mz_sh[BSZ], mKc_sh[BSZ],</span>
<span class="s">                        mVc_sh[BSZ], Xsk_sh[K_fine*3], Wsk_sh[K_fine];</span>


<span class="s">        if (threadIdx.x&lt;K_fine*3)</span>
<span class="s">        {</span>
<span class="s">            Xsk_sh[threadIdx.x] = Xsk[threadIdx.x];</span>
<span class="s">            if (threadIdx.x&lt;K_fine)</span>
<span class="s">                Wsk_sh[threadIdx.x] = Wsk[threadIdx.x];</span>
<span class="s">        }</span>
<span class="s">        __syncthreads();</span>

<span class="s">        int i, same, near, CJ_start, Nsrc, CJ;</span>

<span class="s">        for (int iblock=0; iblock&lt;BpT; iblock++)</span>
<span class="s">        {</span>
<span class="s">            REAL sum_K = 0., sum_V = 0.;</span>
<span class="s">            i  = I + iblock*BSZ;</span>
<span class="s">            xi = xt[i];</span>
<span class="s">            yi = yt[i];</span>
<span class="s">            zi = zt[i];</span>
<span class="s">            int an_counter = 0;</span>

<span class="s">            for (int lst=list_start; lst&lt;list_end; lst++)</span>
<span class="s">            {</span>
<span class="s">                CJ = P2P_list[ptr_lst+lst];</span>
<span class="s">                CJ_start = offSrc[CJ];</span>
<span class="s">                Nsrc = offSrc[CJ+1] - CJ_start;</span>

<span class="s">                for(int jblock=0; jblock&lt;(Nsrc-1)/BSZ; jblock++)</span>
<span class="s">                {</span>
<span class="s">                    __syncthreads();</span>
<span class="s">                    xj_sh[threadIdx.x] = xj[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    yj_sh[threadIdx.x] = yj[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    zj_sh[threadIdx.x] = zj[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    m_sh[threadIdx.x]  = m[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    mx_sh[threadIdx.x] = mx[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    my_sh[threadIdx.x] = my[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    mz_sh[threadIdx.x] = mz[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    mKc_sh[threadIdx.x] = mKc[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    mVc_sh[threadIdx.x] = mVc[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    A_sh[threadIdx.x]  = Area[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    sglInt_sh[threadIdx.x]  = sglInt[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    k_sh[threadIdx.x]  = k[CJ_start + jblock*BSZ + threadIdx.x];</span>

<span class="s">                    for (int vert=0; vert&lt;9; vert++)</span>
<span class="s">                    {</span>
<span class="s">                        ver_sh[9*threadIdx.x+vert] = vertex[9*(CJ_start+jblock*BSZ+threadIdx.x)+vert];</span>
<span class="s">                    }</span>
<span class="s">                    __syncthreads();</span>

<span class="s">                    if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">                    {</span>
<span class="s">                        for (int j=0; j&lt;BSZ; j++)</span>
<span class="s">                        {</span>
<span class="s">                            dx = xi - (ver_sh[9*j] + ver_sh[9*j+3] + ver_sh[9*j+6])  *0.333333333333333333;</span>
<span class="s">                            dy = yi - (ver_sh[9*j+1] + ver_sh[9*j+4] + ver_sh[9*j+7])*0.333333333333333333;</span>
<span class="s">                            dz = zi - (ver_sh[9*j+2] + ver_sh[9*j+5] + ver_sh[9*j+8])*0.333333333333333333;</span>
<span class="s">                            r  = 1/(dx*dx + dy*dy + dz*dz); // r is 1/r!!!</span>
<span class="s">                            same = (r&gt;1e12);</span>
<span class="s">                            near = ((2*A_sh[j]*r) &gt; threshold*threshold);</span>
<span class="s">                            auxV = 0.;</span>
<span class="s">                            auxK = 0.;</span>

<span class="s">                            if (near==0)</span>
<span class="s">                            {</span>
<span class="s">                                dx = xi - xj_sh[j];</span>
<span class="s">                                dy = yi - yj_sh[j];</span>
<span class="s">                                dz = zi - zj_sh[j];</span>
<span class="s">                                r = rsqrt(dx*dx + dy*dy + dz*dz); // r is 1/r!!!!</span>
<span class="s">                                if (LorY==2)</span>
<span class="s">                                {</span>
<span class="s">                                    auxV = exp(-kappa*1/r)*r;</span>
<span class="s">                                    auxK = (mx_sh[j]*dx+my_sh[j]*dy+mz_sh[j]*dz)*auxV*(r)*(kappa+r);</span>
<span class="s">                                    auxV *= m_sh[j];</span>

<span class="s">                                }</span>
<span class="s">                                if (LorY==1)</span>
<span class="s">                                {</span>
<span class="s">                                    auxV =  m_sh[j]*r;</span>
<span class="s">                                    auxK = (mx_sh[j]*dx+my_sh[j]*dy+mz_sh[j]*dz)*(r*r*r);</span>
<span class="s">                                }</span>
<span class="s">                            }</span>

<span class="s">                            if ( (near==1) &amp;&amp; (k_sh[j]==0))</span>
<span class="s">                            {</span>
<span class="s">                                if (same==1)</span>
<span class="s">                                {</span>
<span class="s">                                    auxK = K_diag;</span>
<span class="s">                                    auxV = sglInt_sh[j];</span>
<span class="s">                                }</span>
<span class="s">                                else</span>
<span class="s">                                {</span>
<span class="s">                                    GQ_fine(auxK, auxV, ver_sh, 9*j, xi, yi, zi, kappa, Xsk_sh, Wsk_sh, A_sh, LorY);</span>
<span class="s">                                }</span>

<span class="s">                                auxV *= mVc_sh[j];</span>
<span class="s">                                auxK *= mKc_sh[j];</span>
<span class="s">                                an_counter += 1;</span>
<span class="s">                            }</span>

<span class="s">                            sum_V += auxV;</span>
<span class="s">                            sum_K += auxK;</span>
<span class="s">                        }</span>
<span class="s">                    }</span>
<span class="s">                }</span>
<span class="s">                __syncthreads();</span>
<span class="s">                int jblock = (Nsrc-1)/BSZ;</span>
<span class="s">                if (jblock*BSZ + threadIdx.x &lt; Nsrc)</span>
<span class="s">                {</span>
<span class="s">                    xj_sh[threadIdx.x] = xj[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    yj_sh[threadIdx.x] = yj[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    zj_sh[threadIdx.x] = zj[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    m_sh[threadIdx.x] = m[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    mx_sh[threadIdx.x] = mx[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    my_sh[threadIdx.x] = my[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    mz_sh[threadIdx.x] = mz[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    mKc_sh[threadIdx.x] = mKc[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    mVc_sh[threadIdx.x] = mVc[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    A_sh[threadIdx.x] = Area[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    sglInt_sh[threadIdx.x] = sglInt[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    k_sh[threadIdx.x] = k[CJ_start + jblock*BSZ + threadIdx.x];</span>

<span class="s">                    for (int vert=0; vert&lt;9; vert++)</span>
<span class="s">                    {</span>
<span class="s">                        ver_sh[9*threadIdx.x+vert] = vertex[9*(CJ_start+jblock*BSZ+threadIdx.x)+vert];</span>
<span class="s">                    }</span>
<span class="s">                }</span>
<span class="s">                __syncthreads();</span>

<span class="s">                if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">                {</span>
<span class="s">                    for (int j=0; j&lt;Nsrc-(jblock*BSZ); j++)</span>
<span class="s">                    {</span>
<span class="s">                        dx = xi - (ver_sh[9*j] + ver_sh[9*j+3] + ver_sh[9*j+6])  *0.3333333333333333333;</span>
<span class="s">                        dy = yi - (ver_sh[9*j+1] + ver_sh[9*j+4] + ver_sh[9*j+7])*0.3333333333333333333;</span>
<span class="s">                        dz = zi - (ver_sh[9*j+2] + ver_sh[9*j+5] + ver_sh[9*j+8])*0.3333333333333333333;</span>
<span class="s">                        r  = 1/(dx*dx + dy*dy + dz*dz); // r is 1/r!!!</span>
<span class="s">                        same = (r&gt;1e12);</span>
<span class="s">                        near = ((2*A_sh[j]*r) &gt; threshold*threshold);</span>
<span class="s">                        auxV = 0.;</span>
<span class="s">                        auxK = 0.;</span>

<span class="s">                        if (near==0)</span>
<span class="s">                        {</span>
<span class="s">                            dx = xi - xj_sh[j];</span>
<span class="s">                            dy = yi - yj_sh[j];</span>
<span class="s">                            dz = zi - zj_sh[j];</span>
<span class="s">                            r = rsqrt(dx*dx + dy*dy + dz*dz);  // r is 1/r!!!</span>

<span class="s">                            if (LorY==2)</span>
<span class="s">                            {</span>
<span class="s">                                auxV = exp(-kappa*1/r)*r;</span>
<span class="s">                                auxK = (mx_sh[j]*dx+my_sh[j]*dy+mz_sh[j]*dz)*auxV*(r)*(kappa+r);</span>
<span class="s">                                auxV *= m_sh[j];</span>
<span class="s">                            }</span>
<span class="s">                            if (LorY==1)</span>
<span class="s">                            {</span>
<span class="s">                                auxV = m_sh[j]*r;</span>
<span class="s">                                auxK = (mx_sh[j]*dx+my_sh[j]*dy+mz_sh[j]*dz)*(r*r*r);</span>
<span class="s">                            }</span>
<span class="s">                        }</span>

<span class="s">                        if ( (near==1) &amp;&amp; (k_sh[j]==0))</span>
<span class="s">                        {</span>
<span class="s">                            if (same==1)</span>
<span class="s">                            {</span>
<span class="s">                                auxK = K_diag;</span>
<span class="s">                                auxV = sglInt_sh[j];</span>
<span class="s">                            }</span>
<span class="s">                            else</span>
<span class="s">                            {</span>
<span class="s">                                GQ_fine(auxK, auxV, ver_sh, 9*j, xi, yi, zi, kappa, Xsk_sh, Wsk_sh, A_sh, LorY);</span>
<span class="s">                            }</span>

<span class="s">                            auxV *= mVc_sh[j];</span>
<span class="s">                            auxK *= mKc_sh[j];</span>
<span class="s">                            an_counter += 1;</span>
<span class="s">                        }</span>

<span class="s">                        sum_V += auxV;</span>
<span class="s">                        sum_K += auxK;</span>
<span class="s">                    }</span>
<span class="s">                }</span>
<span class="s">            }</span>

<span class="s">            if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">            {</span>
<span class="s">                K_gpu[i] += sum_K;</span>
<span class="s">                V_gpu[i] += sum_V;</span>

<span class="s">                AI_int_gpu[i] = an_counter;</span>
<span class="s">            }</span>
<span class="s">        }</span>
<span class="s">    }</span>

<span class="s">    __global__ void P2PKt(REAL *Ktx_gpu, REAL *Kty_gpu, REAL *Ktz_gpu, int *offSrc, int *offTwg, int *P2P_list, int *sizeTar, int *k,</span>
<span class="s">                        REAL *xj, REAL *yj, REAL *zj, REAL *m, REAL *mKtc,</span>
<span class="s">                        REAL *xt, REAL *yt, REAL *zt, REAL *Area, REAL *vertex,</span>
<span class="s">                        int ptr_off, int ptr_lst, int LorY, REAL kappa, REAL threshold,</span>
<span class="s">                        int BpT, int NCRIT, int *AI_int_gpu, REAL *Xsk, REAL *Wsk)</span>
<span class="s">    {</span>
<span class="s">        int I = threadIdx.x + blockIdx.x*NCRIT;</span>
<span class="s">        int list_start = offTwg[ptr_off+blockIdx.x];</span>
<span class="s">        int list_end   = offTwg[ptr_off+blockIdx.x+1];</span>

<span class="s">        REAL xi, yi, zi, dx, dy, dz, r, auxKtx, auxKty, auxKtz;</span>

<span class="s">        __shared__ REAL ver_sh[9*BSZ],</span>
<span class="s">                        xj_sh[BSZ], yj_sh[BSZ], zj_sh[BSZ], A_sh[BSZ], k_sh[BSZ],</span>
<span class="s">                        m_sh[BSZ], mKtc_sh[BSZ],</span>
<span class="s">                        Xsk_sh[K_fine*3], Wsk_sh[K_fine];</span>


<span class="s">        if (threadIdx.x&lt;K_fine*3)</span>
<span class="s">        {</span>
<span class="s">            Xsk_sh[threadIdx.x] = Xsk[threadIdx.x];</span>
<span class="s">            if (threadIdx.x&lt;K_fine)</span>
<span class="s">                Wsk_sh[threadIdx.x] = Wsk[threadIdx.x];</span>
<span class="s">        }</span>
<span class="s">        __syncthreads();</span>

<span class="s">        int i, same, near, CJ_start, Nsrc, CJ;</span>

<span class="s">        for (int iblock=0; iblock&lt;BpT; iblock++)</span>
<span class="s">        {</span>
<span class="s">            REAL sum_Ktx = 0., sum_Kty = 0., sum_Ktz = 0.;</span>
<span class="s">            i  = I + iblock*BSZ;</span>
<span class="s">            xi = xt[i];</span>
<span class="s">            yi = yt[i];</span>
<span class="s">            zi = zt[i];</span>
<span class="s">            int an_counter = 0;</span>

<span class="s">            for (int lst=list_start; lst&lt;list_end; lst++)</span>
<span class="s">            {</span>
<span class="s">                CJ = P2P_list[ptr_lst+lst];</span>
<span class="s">                CJ_start = offSrc[CJ];</span>
<span class="s">                Nsrc = offSrc[CJ+1] - CJ_start;</span>

<span class="s">                for(int jblock=0; jblock&lt;(Nsrc-1)/BSZ; jblock++)</span>
<span class="s">                {</span>
<span class="s">                    __syncthreads();</span>
<span class="s">                    xj_sh[threadIdx.x]   = xj[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    yj_sh[threadIdx.x]   = yj[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    zj_sh[threadIdx.x]   = zj[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    m_sh[threadIdx.x]    = m[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    mKtc_sh[threadIdx.x] = mKtc[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    A_sh[threadIdx.x]    = Area[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    k_sh[threadIdx.x]    = k[CJ_start + jblock*BSZ + threadIdx.x];</span>

<span class="s">                    for (int vert=0; vert&lt;9; vert++)</span>
<span class="s">                    {</span>
<span class="s">                        ver_sh[9*threadIdx.x+vert] = vertex[9*(CJ_start+jblock*BSZ+threadIdx.x)+vert];</span>
<span class="s">                    }</span>
<span class="s">                    __syncthreads();</span>

<span class="s">                    if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">                    {</span>
<span class="s">                        for (int j=0; j&lt;BSZ; j++)</span>
<span class="s">                        {</span>
<span class="s">                            dx = xi - (ver_sh[9*j] + ver_sh[9*j+3] + ver_sh[9*j+6])  *0.333333333333333333;</span>
<span class="s">                            dy = yi - (ver_sh[9*j+1] + ver_sh[9*j+4] + ver_sh[9*j+7])*0.333333333333333333;</span>
<span class="s">                            dz = zi - (ver_sh[9*j+2] + ver_sh[9*j+5] + ver_sh[9*j+8])*0.333333333333333333;</span>
<span class="s">                            r  = 1/(dx*dx + dy*dy + dz*dz); // r is 1/r!!!</span>
<span class="s">                            same = (r&gt;1e12);</span>
<span class="s">                            near = ((2*A_sh[j]*r) &gt; threshold*threshold);</span>
<span class="s">                            auxKtx = 0.;</span>
<span class="s">                            auxKty = 0.;</span>
<span class="s">                            auxKtz = 0.;</span>

<span class="s">                            if (near==0)</span>
<span class="s">                            {</span>
<span class="s">                                dx = xi - xj_sh[j];</span>
<span class="s">                                dy = yi - yj_sh[j];</span>
<span class="s">                                dz = zi - zj_sh[j];</span>
<span class="s">                                r = rsqrt(dx*dx + dy*dy + dz*dz); // r is 1/r!!!!</span>
<span class="s">                                if (LorY==2)</span>
<span class="s">                                {</span>
<span class="s">                                    auxKtx  = -m_sh[j]*exp(-kappa*1/r)*r*r*(kappa+r);</span>
<span class="s">                                    auxKty  = auxKtx*dy;</span>
<span class="s">                                    auxKtz  = auxKtx*dz;</span>
<span class="s">                                    auxKtx *= dx;</span>
<span class="s">                                }</span>
<span class="s">                                if (LorY==1)</span>
<span class="s">                                {</span>
<span class="s">                                    auxKtx  = -m_sh[j]*r*r*r;</span>
<span class="s">                                    auxKty  = auxKtx*dy;</span>
<span class="s">                                    auxKtz  = auxKtx*dz;</span>
<span class="s">                                    auxKtx *= dx;</span>
<span class="s">                                }</span>
<span class="s">                            }</span>

<span class="s">                            if ( (near==1) &amp;&amp; (k_sh[j]==0))</span>
<span class="s">                            {</span>
<span class="s">                                if (same==1)</span>
<span class="s">                                {</span>
<span class="s">                                    auxKtx = 0.0;</span>
<span class="s">                                    auxKty = 0.0;</span>
<span class="s">                                    auxKtz = 0.0;</span>
<span class="s">                                }</span>
<span class="s">                                else</span>
<span class="s">                                {</span>
<span class="s">                                    GQ_fineKt(auxKtx, auxKty, auxKtz, ver_sh, 9*j, xi, yi, zi, kappa, Xsk_sh, Wsk_sh, A_sh, LorY);</span>
<span class="s">                                }</span>

<span class="s">                                auxKtx *= mKtc_sh[j];</span>
<span class="s">                                auxKty *= mKtc_sh[j];</span>
<span class="s">                                auxKtz *= mKtc_sh[j];</span>
<span class="s">                                an_counter += 1;</span>
<span class="s">                            }</span>

<span class="s">                            sum_Ktx += auxKtx;</span>
<span class="s">                            sum_Kty += auxKty;</span>
<span class="s">                            sum_Ktz += auxKtz;</span>
<span class="s">                        }</span>
<span class="s">                    }</span>
<span class="s">                }</span>
<span class="s">                __syncthreads();</span>
<span class="s">                int jblock = (Nsrc-1)/BSZ;</span>
<span class="s">                if (jblock*BSZ + threadIdx.x &lt; Nsrc)</span>
<span class="s">                {</span>
<span class="s">                    xj_sh[threadIdx.x] = xj[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    yj_sh[threadIdx.x] = yj[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    zj_sh[threadIdx.x] = zj[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    m_sh[threadIdx.x] = m[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    mKtc_sh[threadIdx.x] = mKtc[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    A_sh[threadIdx.x] = Area[CJ_start + jblock*BSZ + threadIdx.x];</span>
<span class="s">                    k_sh[threadIdx.x] = k[CJ_start + jblock*BSZ + threadIdx.x];</span>

<span class="s">                    for (int vert=0; vert&lt;9; vert++)</span>
<span class="s">                    {</span>
<span class="s">                        ver_sh[9*threadIdx.x+vert] = vertex[9*(CJ_start+jblock*BSZ+threadIdx.x)+vert];</span>
<span class="s">                    }</span>
<span class="s">                }</span>
<span class="s">                __syncthreads();</span>

<span class="s">                if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">                {</span>
<span class="s">                    for (int j=0; j&lt;Nsrc-(jblock*BSZ); j++)</span>
<span class="s">                    {</span>
<span class="s">                        dx = xi - (ver_sh[9*j] + ver_sh[9*j+3] + ver_sh[9*j+6])  *0.3333333333333333333;</span>
<span class="s">                        dy = yi - (ver_sh[9*j+1] + ver_sh[9*j+4] + ver_sh[9*j+7])*0.3333333333333333333;</span>
<span class="s">                        dz = zi - (ver_sh[9*j+2] + ver_sh[9*j+5] + ver_sh[9*j+8])*0.3333333333333333333;</span>
<span class="s">                        r  = 1/(dx*dx + dy*dy + dz*dz); // r is 1/r!!!</span>
<span class="s">                        same = (r&gt;1e12);</span>
<span class="s">                        near = ((2*A_sh[j]*r) &gt; threshold*threshold);</span>
<span class="s">                        auxKtx = 0.;</span>
<span class="s">                        auxKty = 0.;</span>
<span class="s">                        auxKtz = 0.;</span>

<span class="s">                        if (near==0)</span>
<span class="s">                        {</span>
<span class="s">                            dx = xi - xj_sh[j];</span>
<span class="s">                            dy = yi - yj_sh[j];</span>
<span class="s">                            dz = zi - zj_sh[j];</span>
<span class="s">                            r = rsqrt(dx*dx + dy*dy + dz*dz);  // r is 1/r!!!</span>

<span class="s">                            if (LorY==2)</span>
<span class="s">                            {</span>
<span class="s">                                auxKtx  = -m_sh[j]*exp(-kappa*1/r)*r*r*(kappa+r);</span>
<span class="s">                                auxKty  = auxKtx*dy;</span>
<span class="s">                                auxKtz  = auxKtx*dz;</span>
<span class="s">                                auxKtx *= dx;</span>
<span class="s">                            }</span>
<span class="s">                            if (LorY==1)</span>
<span class="s">                            {</span>
<span class="s">                                auxKtx  = -m_sh[j]*r*r*r;</span>
<span class="s">                                auxKty  = auxKtx*dy;</span>
<span class="s">                                auxKtz  = auxKtx*dz;</span>
<span class="s">                                auxKtx *= dx;</span>
<span class="s">                            }</span>
<span class="s">                        }</span>

<span class="s">                        if ( (near==1) &amp;&amp; (k_sh[j]==0))</span>
<span class="s">                        {</span>
<span class="s">                            if (same==1)</span>
<span class="s">                            {</span>
<span class="s">                                auxKtx = 0.0;</span>
<span class="s">                                auxKty = 0.0;</span>
<span class="s">                                auxKtz = 0.0;</span>
<span class="s">                            }</span>
<span class="s">                            else</span>
<span class="s">                            {</span>
<span class="s">                                GQ_fineKt(auxKtx, auxKty, auxKtz, ver_sh, 9*j, xi, yi, zi, kappa, Xsk_sh, Wsk_sh, A_sh, LorY);</span>
<span class="s">                            }</span>

<span class="s">                            auxKtx *= mKtc_sh[j];</span>
<span class="s">                            auxKty *= mKtc_sh[j];</span>
<span class="s">                            auxKtz *= mKtc_sh[j];</span>
<span class="s">                            an_counter += 1;</span>
<span class="s">                        }</span>

<span class="s">                        sum_Ktx += auxKtx;</span>
<span class="s">                        sum_Kty += auxKty;</span>
<span class="s">                        sum_Ktz += auxKtz;</span>
<span class="s">                    }</span>
<span class="s">                }</span>
<span class="s">            }</span>

<span class="s">            if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">            {</span>
<span class="s">                Ktx_gpu[i] += sum_Ktx;</span>
<span class="s">                Kty_gpu[i] += sum_Kty;</span>
<span class="s">                Ktz_gpu[i] += sum_Ktz;</span>

<span class="s">                AI_int_gpu[i] = an_counter;</span>
<span class="s">            }</span>
<span class="s">        }</span>
<span class="s">    }</span>

<span class="s">    __global__ void get_phir(REAL *phir, REAL *xq, REAL *yq, REAL *zq,</span>
<span class="s">                            REAL *m, REAL *mx, REAL *my, REAL *mz, REAL *mKc, REAL *mVc,</span>
<span class="s">                            REAL *xj, REAL *yj, REAL *zj, REAL *Area, int *k, REAL *vertex,</span>
<span class="s">                            int Nj, int Nq, int K, REAL *xk, REAL *wk,</span>
<span class="s">                            REAL threshold, int *AI_int_gpu, int Nk, REAL *Xsk, REAL *Wsk)</span>
<span class="s">    {</span>
<span class="s">        int i = threadIdx.x + blockIdx.x*BSZ;</span>
<span class="s">        REAL xi, yi, zi, dx, dy, dz, r;</span>
<span class="s">        int jblock, triangle;</span>

<span class="s">        __shared__ REAL ver_sh[9*BSZ],</span>
<span class="s">                        xj_sh[BSZ], yj_sh[BSZ], zj_sh[BSZ], A_sh[BSZ], k_sh[BSZ],</span>
<span class="s">                        m_sh[BSZ], mx_sh[BSZ], my_sh[BSZ], mz_sh[BSZ], mKc_sh[BSZ],</span>
<span class="s">                        mVc_sh[BSZ];</span>



<span class="s">        REAL sum_V = 0., sum_K = 0.;</span>
<span class="s">        xi = xq[i];</span>
<span class="s">        yi = yq[i];</span>
<span class="s">        zi = zq[i];</span>
<span class="s">        int an_counter = 0;</span>

<span class="s">        for(jblock=0; jblock&lt;(Nj-1)/BSZ; jblock++)</span>
<span class="s">        {</span>
<span class="s">            __syncthreads();</span>
<span class="s">            xj_sh[threadIdx.x] = xj[jblock*BSZ + threadIdx.x];</span>
<span class="s">            yj_sh[threadIdx.x] = yj[jblock*BSZ + threadIdx.x];</span>
<span class="s">            zj_sh[threadIdx.x] = zj[jblock*BSZ + threadIdx.x];</span>
<span class="s">            m_sh[threadIdx.x]  = m[jblock*BSZ + threadIdx.x];</span>
<span class="s">            mx_sh[threadIdx.x] = mx[jblock*BSZ + threadIdx.x];</span>
<span class="s">            my_sh[threadIdx.x] = my[jblock*BSZ + threadIdx.x];</span>
<span class="s">            mz_sh[threadIdx.x] = mz[jblock*BSZ + threadIdx.x];</span>
<span class="s">            mKc_sh[threadIdx.x] = mKc[jblock*BSZ + threadIdx.x];</span>
<span class="s">            mVc_sh[threadIdx.x] = mVc[jblock*BSZ + threadIdx.x];</span>
<span class="s">            k_sh[threadIdx.x]  = k[jblock*BSZ + threadIdx.x];</span>
<span class="s">            A_sh[threadIdx.x]  = Area[(jblock*BSZ + threadIdx.x)];</span>
<span class="s">            for (int vert=0; vert&lt;9; vert++)</span>
<span class="s">            {</span>
<span class="s">                triangle = jblock*BSZ+threadIdx.x;</span>
<span class="s">                ver_sh[9*threadIdx.x+vert] = vertex[9*triangle+vert];</span>
<span class="s">            }</span>
<span class="s">            __syncthreads();</span>

<span class="s">            for (int j=0; j&lt;BSZ; j++)</span>
<span class="s">            {</span>
<span class="s">                dx = xi - (ver_sh[9*j] + ver_sh[9*j+3] + ver_sh[9*j+6])/3;</span>
<span class="s">                dy = yi - (ver_sh[9*j+1] + ver_sh[9*j+4] + ver_sh[9*j+7])/3;</span>
<span class="s">                dz = zi - (ver_sh[9*j+2] + ver_sh[9*j+5] + ver_sh[9*j+8])/3;</span>
<span class="s">                r  = sqrt(dx*dx + dy*dy + dz*dz);</span>

<span class="s">                if((sqrt(2*A_sh[j])/r) &lt; threshold)</span>
<span class="s">                {</span>
<span class="s">                    dx = xi - xj_sh[j];</span>
<span class="s">                    dy = yi - yj_sh[j];</span>
<span class="s">                    dz = zi - zj_sh[j];</span>
<span class="s">                    r = sqrt(dx*dx + dy*dy + dz*dz);</span>
<span class="s">                    sum_V  += m_sh[j]/r;</span>
<span class="s">                    sum_K += (mx_sh[j]*dx+my_sh[j]*dy+mz_sh[j]*dz)/(r*r*r);</span>
<span class="s">                }</span>
<span class="s">                else if(k_sh[j]==0)</span>
<span class="s">                {</span>
<span class="s">                    REAL PHI_K = 0.;</span>
<span class="s">                    REAL PHI_V = 0.;</span>

<span class="s">                    GQ_fine(PHI_K, PHI_V, ver_sh, 9*j, xi, yi, zi, 1e-15, Xsk, Wsk, A_sh, 1);</span>
<span class="s">                    //REAL panel[9] = {ver_sh[9*j], ver_sh[9*j+1], ver_sh[9*j+2],</span>
<span class="s">                    //                 ver_sh[9*j+3], ver_sh[9*j+4], ver_sh[9*j+5],</span>
<span class="s">                    //                 ver_sh[9*j+6], ver_sh[9*j+7], ver_sh[9*j+8]};</span>
<span class="s">                    //SA(PHI_K, PHI_V, panel, xi, yi, zi,</span>
<span class="s">                    //   1., 1., 1e-15, 0, xk, wk, 9, 1);</span>

<span class="s">                    sum_V += PHI_V * mVc_sh[j];</span>
<span class="s">                    sum_K += PHI_K * mKc_sh[j];</span>
<span class="s">                    an_counter += 1;</span>
<span class="s">                }</span>
<span class="s">            }</span>
<span class="s">        }</span>

<span class="s">        __syncthreads();</span>
<span class="s">        jblock = (Nj-1)/BSZ;</span>
<span class="s">        if (threadIdx.x&lt;Nj-jblock*BSZ)</span>
<span class="s">        {</span>
<span class="s">            xj_sh[threadIdx.x] = xj[jblock*BSZ + threadIdx.x];</span>
<span class="s">            yj_sh[threadIdx.x] = yj[jblock*BSZ + threadIdx.x];</span>
<span class="s">            zj_sh[threadIdx.x] = zj[jblock*BSZ + threadIdx.x];</span>
<span class="s">            m_sh[threadIdx.x]  = m[jblock*BSZ + threadIdx.x];</span>
<span class="s">            mx_sh[threadIdx.x] = mx[jblock*BSZ + threadIdx.x];</span>
<span class="s">            my_sh[threadIdx.x] = my[jblock*BSZ + threadIdx.x];</span>
<span class="s">            mz_sh[threadIdx.x] = mz[jblock*BSZ + threadIdx.x];</span>
<span class="s">            mKc_sh[threadIdx.x] = mKc[jblock*BSZ + threadIdx.x];</span>
<span class="s">            mVc_sh[threadIdx.x] = mVc[jblock*BSZ + threadIdx.x];</span>
<span class="s">            k_sh[threadIdx.x]  = k[jblock*BSZ + threadIdx.x];</span>
<span class="s">            A_sh[threadIdx.x]  = Area[jblock*BSZ + threadIdx.x];</span>

<span class="s">            for (int vert=0; vert&lt;9; vert++)</span>
<span class="s">            {</span>
<span class="s">                triangle = jblock*BSZ+threadIdx.x;</span>
<span class="s">                ver_sh[9*threadIdx.x+vert] = vertex[9*triangle+vert];</span>
<span class="s">            }</span>
<span class="s">        }</span>
<span class="s">        __syncthreads();</span>


<span class="s">        for (int j=0; j&lt;Nj-(jblock*BSZ); j++)</span>
<span class="s">        {</span>
<span class="s">            dx = xi - (ver_sh[9*j] + ver_sh[9*j+3] + ver_sh[9*j+6])/3;</span>
<span class="s">            dy = yi - (ver_sh[9*j+1] + ver_sh[9*j+4] + ver_sh[9*j+7])/3;</span>
<span class="s">            dz = zi - (ver_sh[9*j+2] + ver_sh[9*j+5] + ver_sh[9*j+8])/3;</span>
<span class="s">            r  = sqrt(dx*dx + dy*dy + dz*dz);</span>

<span class="s">            if (i&lt;Nq)</span>
<span class="s">            {</span>
<span class="s">                if ((sqrt(2*A_sh[j])/r) &lt; threshold)</span>
<span class="s">                {</span>
<span class="s">                    dx = xi - xj_sh[j];</span>
<span class="s">                    dy = yi - yj_sh[j];</span>
<span class="s">                    dz = zi - zj_sh[j];</span>
<span class="s">                    r = sqrt(dx*dx + dy*dy + dz*dz);</span>
<span class="s">                    sum_V  += m_sh[j]/r;</span>
<span class="s">                    sum_K += (mx_sh[j]*dx+my_sh[j]*dy+mz_sh[j]*dz)/(r*r*r);</span>
<span class="s">                }</span>

<span class="s">                else if(k_sh[j]==0)</span>
<span class="s">                {</span>
<span class="s">                    REAL PHI_K = 0.;</span>
<span class="s">                    REAL PHI_V = 0.;</span>

<span class="s">                    GQ_fine(PHI_K, PHI_V, ver_sh, 9*j, xi, yi, zi, 1e-15, Xsk, Wsk, A_sh, 1);</span>

<span class="s">                    sum_V += PHI_V * mVc_sh[j];</span>
<span class="s">                    sum_K += PHI_K * mKc_sh[j];</span>

<span class="s">                    an_counter += 1;</span>
<span class="s">                }</span>
<span class="s">            }</span>
<span class="s">        }</span>

<span class="s">        if (i&lt;Nq)</span>
<span class="s">        {</span>
<span class="s">            phir[i] = (-sum_K + sum_V)/(4*M_PI);</span>
<span class="s">            AI_int_gpu[i] = an_counter;</span>
<span class="s">        }</span>
<span class="s">    }</span>

<span class="s">    __global__ void compute_RHS(REAL *F, REAL *xq, REAL *yq, REAL *zq,</span>
<span class="s">                                REAL *q, REAL *xi, REAL *yi, REAL *zi,</span>
<span class="s">                                int *sizeTar, int Nq, REAL E_1,</span>
<span class="s">                                int NCRIT, int BpT)</span>
<span class="s">    {</span>
<span class="s">        int II = threadIdx.x + blockIdx.x*NCRIT;</span>
<span class="s">        int I;</span>
<span class="s">        REAL x, y, z, sum;</span>
<span class="s">        REAL dx, dy, dz, r;</span>
<span class="s">        __shared__ REAL xq_sh[BSZ], yq_sh[BSZ], zq_sh[BSZ], q_sh[BSZ];</span>

<span class="s">        for (int iblock=0; iblock&lt;BpT; iblock++)</span>
<span class="s">        {</span>
<span class="s">            I = II + iblock*BSZ;</span>
<span class="s">            x = xi[I];</span>
<span class="s">            y = yi[I];</span>
<span class="s">            z = zi[I];</span>
<span class="s">            sum = 0.;</span>

<span class="s">            for (int block=0; block&lt;(Nq-1)/BSZ; block++)</span>
<span class="s">            {</span>
<span class="s">                __syncthreads();</span>
<span class="s">                xq_sh[threadIdx.x] = xq[block*BSZ+threadIdx.x];</span>
<span class="s">                yq_sh[threadIdx.x] = yq[block*BSZ+threadIdx.x];</span>
<span class="s">                zq_sh[threadIdx.x] = zq[block*BSZ+threadIdx.x];</span>
<span class="s">                q_sh[threadIdx.x]  = q[block*BSZ+threadIdx.x];</span>
<span class="s">                __syncthreads();</span>

<span class="s">                if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">                {</span>
<span class="s">                    for (int i=0; i&lt;BSZ; i++)</span>
<span class="s">                    {</span>
<span class="s">                        dx = xq_sh[i] - x;</span>
<span class="s">                        dy = yq_sh[i] - y;</span>
<span class="s">                        dz = zq_sh[i] - z;</span>
<span class="s">                        r  = sqrt(dx*dx + dy*dy + dz*dz);</span>

<span class="s">                        sum += q_sh[i]/(E_1*r);</span>
<span class="s">                    }</span>
<span class="s">                }</span>
<span class="s">            }</span>

<span class="s">            int block = (Nq-1)/BSZ;</span>
<span class="s">            __syncthreads();</span>
<span class="s">            xq_sh[threadIdx.x] = xq[block*BSZ+threadIdx.x];</span>
<span class="s">            yq_sh[threadIdx.x] = yq[block*BSZ+threadIdx.x];</span>
<span class="s">            zq_sh[threadIdx.x] = zq[block*BSZ+threadIdx.x];</span>
<span class="s">            q_sh[threadIdx.x]  = q[block*BSZ+threadIdx.x];</span>
<span class="s">            __syncthreads();</span>

<span class="s">            if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">            {</span>
<span class="s">                for (int i=0; i&lt;Nq-block*BSZ; i++)</span>
<span class="s">                {</span>
<span class="s">                    dx = xq_sh[i] - x;</span>
<span class="s">                    dy = yq_sh[i] - y;</span>
<span class="s">                    dz = zq_sh[i] - z;</span>
<span class="s">                    r  = sqrt(dx*dx + dy*dy + dz*dz);</span>

<span class="s">                    sum += q_sh[i]/(E_1*r);</span>
<span class="s">                }</span>
<span class="s">            }</span>

<span class="s">            if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">            {</span>
<span class="s">                F[I] = sum;</span>
<span class="s">            }</span>
<span class="s">        }</span>
<span class="s">    }</span>

<span class="s">    __global__ void compute_RHSKt(REAL *Fx, REAL *Fy, REAL *Fz, REAL *xq, REAL *yq, REAL *zq,</span>
<span class="s">                                REAL *q, REAL *xi, REAL *yi, REAL *zi,</span>
<span class="s">                                int *sizeTar, int Nq, REAL E_1,</span>
<span class="s">                                int NCRIT, int BpT)</span>
<span class="s">    {</span>
<span class="s">        int II = threadIdx.x + blockIdx.x*NCRIT;</span>
<span class="s">        int I;</span>
<span class="s">        REAL x, y, z, sum_x, sum_y, sum_z;</span>
<span class="s">        REAL dx, dy, dz, r, aux;</span>
<span class="s">        __shared__ REAL xq_sh[BSZ], yq_sh[BSZ], zq_sh[BSZ], q_sh[BSZ];</span>

<span class="s">        for (int iblock=0; iblock&lt;BpT; iblock++)</span>
<span class="s">        {</span>
<span class="s">            I = II + iblock*BSZ;</span>
<span class="s">            x = xi[I];</span>
<span class="s">            y = yi[I];</span>
<span class="s">            z = zi[I];</span>
<span class="s">            sum_x = 0., sum_y = 0, sum_z = 0;</span>

<span class="s">            for (int block=0; block&lt;(Nq-1)/BSZ; block++)</span>
<span class="s">            {</span>
<span class="s">                __syncthreads();</span>
<span class="s">                xq_sh[threadIdx.x] = xq[block*BSZ+threadIdx.x];</span>
<span class="s">                yq_sh[threadIdx.x] = yq[block*BSZ+threadIdx.x];</span>
<span class="s">                zq_sh[threadIdx.x] = zq[block*BSZ+threadIdx.x];</span>
<span class="s">                q_sh[threadIdx.x]  = q[block*BSZ+threadIdx.x];</span>
<span class="s">                __syncthreads();</span>

<span class="s">                if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">                {</span>
<span class="s">                    for (int i=0; i&lt;BSZ; i++)</span>
<span class="s">                    {</span>
<span class="s">                        dx = x - xq_sh[i];</span>
<span class="s">                        dy = y - yq_sh[i];</span>
<span class="s">                        dz = z - zq_sh[i];</span>
<span class="s">                        r  = sqrt(dx*dx + dy*dy + dz*dz);</span>
<span class="s">                        aux = -q_sh[i]/(r*r*r);</span>

<span class="s">                        sum_x += aux*dx;</span>
<span class="s">                        sum_y += aux*dy;</span>
<span class="s">                        sum_z += aux*dz;</span>
<span class="s">                    }</span>
<span class="s">                }</span>
<span class="s">            }</span>

<span class="s">            int block = (Nq-1)/BSZ;</span>
<span class="s">            __syncthreads();</span>
<span class="s">            xq_sh[threadIdx.x] = xq[block*BSZ+threadIdx.x];</span>
<span class="s">            yq_sh[threadIdx.x] = yq[block*BSZ+threadIdx.x];</span>
<span class="s">            zq_sh[threadIdx.x] = zq[block*BSZ+threadIdx.x];</span>
<span class="s">            q_sh[threadIdx.x]  = q[block*BSZ+threadIdx.x];</span>
<span class="s">            __syncthreads();</span>

<span class="s">            if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">            {</span>
<span class="s">                for (int i=0; i&lt;Nq-block*BSZ; i++)</span>
<span class="s">                {</span>
<span class="s">                    dx = x - xq_sh[i];</span>
<span class="s">                    dy = y - yq_sh[i];</span>
<span class="s">                    dz = z - zq_sh[i];</span>
<span class="s">                    r  = sqrt(dx*dx + dy*dy + dz*dz);</span>
<span class="s">                    aux = -q_sh[i]/(r*r*r);</span>

<span class="s">                    sum_x += aux*dx;</span>
<span class="s">                    sum_y += aux*dy;</span>
<span class="s">                    sum_z += aux*dz;</span>
<span class="s">                }</span>
<span class="s">            }</span>

<span class="s">            if (threadIdx.x+iblock*BSZ&lt;sizeTar[blockIdx.x])</span>
<span class="s">            {</span>
<span class="s">                Fx[I] = sum_x;</span>
<span class="s">                Fy[I] = sum_y;</span>
<span class="s">                Fz[I] = sum_z;</span>
<span class="s">            }</span>
<span class="s">        }</span>
<span class="s">    }</span>


<span class="s">    &quot;&quot;&quot;</span><span class="o">%</span><span class="p">{</span><span class="s">&#39;blocksize&#39;</span><span class="p">:</span><span class="n">BSZ</span><span class="p">,</span> <span class="s">&#39;Nmult&#39;</span><span class="p">:</span><span class="n">Nm</span><span class="p">,</span> <span class="s">&#39;K_near&#39;</span><span class="p">:</span><span class="n">K_fine</span><span class="p">,</span> <span class="s">&#39;Ptree&#39;</span><span class="p">:</span><span class="n">P</span><span class="p">,</span> <span class="s">&#39;precision&#39;</span><span class="p">:</span><span class="n">REAL</span><span class="p">},</span> <span class="n">nvcc</span><span class="o">=</span><span class="s">&quot;nvcc&quot;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;-use_fast_math&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">mod</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Christopher Cooper, Natalia Clementi, Gil Forsyth, Lorena Barba.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
    </div>

    

    
  </body>
</html>